<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>√Årnykocka ‚Äì A L√©lekpr√≥ba</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Cinzel', serif;
      background: #0e0e0e;
      color: #f2f2f2;
      text-align: center;
      padding: 20px;
      background-image: radial-gradient(circle at center, #1a0029 0%, #0e0e0e 100%);
      min-height: 100vh;
      margin: 0;
    }
    h1 {
      color: #bb00ff;
      text-shadow: 0 0 10px #bb00ff;
      font-size: 2.4rem;
      margin-top: 30px;
    }
    .kockak {
      font-size: 2rem;
      margin: 15px 0;
      padding: 15px;
      background: rgba(20, 0, 30, 0.6);
      border-radius: 8px;
      box-shadow: 0 0 15px rgba(187, 0, 255, 0.2);
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .log {
      margin-top: 25px;
      white-space: pre-line;
      background: rgba(0,0,0,0.5);
      border: 1px solid #444;
      padding: 15px;
      border-radius: 8px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      min-height: 150px;
      text-align: left;
      color: #d1c3af;
      line-height: 1.5;
    }
    #status {
      background: rgba(20, 0, 30, 0.4);
      border-radius: 8px;
      padding: 10px;
      margin: 15px auto;
      max-width: 500px;
      font-size: 1.2rem;
    }
    button {
      background: #7f00ff;
      color: white;
      border: none;
      padding: 12px 25px;
      margin: 8px;
      font-size: 1.1rem;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 0 10px #7f00ff;
      transition: all 0.3s;
      font-family: 'Cinzel', serif;
    }
    button:hover {
      background: #a94bff;
      transform: scale(1.05);
      box-shadow: 0 0 15px #bb00ff;
    }
    #actions {
      margin: 20px 0;
    }
    .claim-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
      max-width: 600px;
      margin: 0 auto;
    }
    .claim-buttons button {
      padding: 8px 15px;
      min-width: 50px;
    }
    .essence-count {
      color: #bb00ff;
      font-weight: bold;
      text-shadow: 0 0 5px #bb00ff;
    }
    .thinking {
      font-style: italic;
      color: #a1a1a1;
      margin: 10px 0;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.5; }
      50% { opacity: 1; }
      100% { opacity: 0.5; }
    }
    .history-item {
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(127, 0, 255, 0.2);
    }
  </style>
</head>
<body>

<h1>√Årnykocka ‚Äì A L√©lekpr√≥ba</h1>

<div id="status"></div>
<div class="kockak" id="playerRolls"></div>
<div class="kockak" id="opponentRolls"></div>

<div id="actions">
  <button onclick="playerRoll()">üé≤ Dob√°s</button>
</div>

<div id="log" class="log"></div>

<script>
// J√°t√©k√°llapot
let playerEssence = 0;
let opponentEssence = 0;
let playerDice = [];
let opponentDice = [];
let roundPhase = 0; // 0 = dob√°s, 1 = bemond√°s, 2 = d√∂nt√©s, 3 = eredm√©ny
let claimValue = 0;
let gameHistory = []; // j√°t√©kos kor√°bbi l√©p√©seinek k√∂vet√©se
let currentRound = 0;

// Seg√©df√ºggv√©nyek
function randomDice(max = 6) {
  return Math.floor(Math.random() * max) + 1;
}

function calculateTotal(dice) {
  return dice[0]*2 + dice[1] + dice[2];
}

function calculateMaximumPossible(dice) {
  return 8*2 + 6 + 6; // a teoretikus maximum
}

// J√°t√©kos l√©p√©sek
function playerRoll() {
  currentRound++;
  playerDice = [randomDice(8), randomDice(), randomDice()];
  opponentDice = [randomDice(8), randomDice(), randomDice()]; // Az ellenf√©l is dob
  
  // Az AI-nak ismert a saj√°t dob√°sa, nek√ºnk nem
  const opponentTotal = calculateTotal(opponentDice);
  
  roundPhase = 1;
  document.getElementById("playerRolls").textContent = `üé≤ Saj√°t dob√°said: [${playerDice.join(', ')}] (Nagy: ${playerDice[0]} ‚ú¶)`;
  document.getElementById("opponentRolls").textContent = "";
  document.getElementById("log").textContent = `${currentRound}. k√∂r kezd≈ëdik... a s√∂t√©ts√©g leple m√∂g√∂tt valami mozog.`;
  
  showClaimOptions();
  updateStatus();
}

function showClaimOptions() {
  const playerTotal = calculateTotal(playerDice);
  const max = calculateMaximumPossible(playerDice);
  const min = 4; // legkisebb re√°lis minimum
  
  let html = "<p>Milyen √©rt√©ket mondasz be?</p><div class='claim-buttons'>";
  
  // T√∂bb v√°laszt√°si lehet≈ës√©g, az ir√°ny√≠t√°s jobban a j√°t√©kosn√°l
  for (let i = min; i <= Math.min(max + 8, 40); i++) {
    const buttonClass = i <= playerTotal ? "" : "bluff";
    html += `<button onclick="makeClaim(${i})">${i}</button>`;
  }
  
  html += "</div>";
  document.getElementById("actions").innerHTML = html;
}

function makeClaim(value) {
  claimValue = value;
  roundPhase = 2;
  
  // R√∂gz√≠tj√ºk a j√°t√©kos l√©p√©s√©t az el≈ëzm√©nyekbe
  const actualValue = calculateTotal(playerDice);
  const isBluff = value > actualValue;
  
  gameHistory.push({
    round: currentRound,
    claimed: value,
    actual: actualValue,
    bluffed: isBluff
  });
  
  document.getElementById("log").textContent = `‚ò†Ô∏è Bemondtad: ${value}`;
  
  // Mostant√≥l az AI d√∂nt
  document.getElementById("actions").innerHTML = `<div class="thinking">Ellenfeled m√©rlegeli a helyzetet...</div>`;
  
  // K√©sleltet√©s az AI gondolkod√°s√°nak szimul√°l√°s√°hoz
  setTimeout(() => {
    makeOpponentDecision();
  }, 1500);
}

// AI gondolkod√°sa
function makeOpponentDecision() {
  const maxPossible = calculateMaximumPossible();
  
  // AI saj√°t kock√°inak √©rt√©ke
  const aiTotal = calculateTotal(opponentDice);
  
  // Statisztikai elemz√©shez
  let bluffProbability = 0.5; // Alap val√≥sz√≠n≈±s√©g
  
  // 1. T√©nyez≈ë: Mennyire val√≥sz√≠n≈±tlen a bemondott √©rt√©k
  const unlikeliness = (claimValue / maxPossible); // Min√©l magasabb, ann√°l gyan√∫sabb
  bluffProbability += (unlikeliness - 0.5) * 0.5;
  
  // 2. T√©nyez≈ë: J√°t√©kos el≈ëzm√©nyei
  if (gameHistory.length > 2) {
    const lastFew = gameHistory.slice(-Math.min(5, gameHistory.length));
    const bluffRatio = lastFew.filter(h => h.bluffed).length / lastFew.length;
    
    // Ha a j√°t√©kos sokat bl√∂ff√∂l, n√∂velj√ºk a k√©tked√©s es√©ly√©t
    bluffProbability += (bluffRatio - 0.5) * 0.3;
    
    // Ha a j√°t√©kos mint√°zatot k√∂vet, pr√≥b√°ljuk elkapni
    if (gameHistory.length >= 3) {
      const lastTwo = [
        gameHistory[gameHistory.length - 2].bluffed,
        gameHistory[gameHistory.length - 1].bluffed
      ];
      
      // Ha az utols√≥ k√©t k√∂r ugyanolyan volt (mindkett≈ë igaz vagy mindkett≈ë bl√∂ff),
      // felt√©telezz√ºk, hogy a j√°t√©kos v√°ltani fog
      if (lastTwo[0] === lastTwo[1]) {
        // Ha mindkett≈ë igaz, akkor most bl√∂ff√∂t v√°runk
        if (!lastTwo[0]) bluffProbability += 0.1;
        // Ha mindkett≈ë bl√∂ff, akkor most igaz √°ll√≠t√°st v√°runk
        else bluffProbability -= 0.1;
      }
    }
  }
  
  // 3. T√©nyez≈ë: J√°t√©k√°ll√°s befoly√°sa
  const scoreDiff = playerEssence - opponentEssence;
  
  // Ha az AI veszt√©sre √°ll, nagyobb kock√°zatot v√°llal
  if (scoreDiff > 0) {
    bluffProbability -= 0.1 * scoreDiff; // Kev√©sb√© val√≥sz√≠n≈±, hogy k√©tkedik
  }
  // Ha az AI vezet, konzervat√≠vabb
  else if (scoreDiff < 0) {
    bluffProbability += 0.05 * Math.abs(scoreDiff); // Val√≥sz√≠n≈±bb, hogy k√©tkedik
  }
  
  // 4. T√©nyez≈ë: Ellenf√©l saj√°t kock√°inak ismerete
  // Ha az AI tudja, hogy a saj√°t dob√°sa magas, akkor a j√°t√©kos val√≥sz√≠n≈±leg nem merne t√∫l nagyot bl√∂ff√∂lni
  if (aiTotal > 20) {
    bluffProbability -= 0.2;
  }
  
  // 5. T√©nyez≈ë: Ha a bemondott √©rt√©k k√∂zel van a maximumhoz
  if (claimValue > maxPossible * 0.75) {
    bluffProbability += 0.2;
  }
  
  // 6. T√©nyez≈ë: V√©letlen elem az AI kisz√°m√≠thatatlans√°g√°√©rt
  bluffProbability += (Math.random() * 0.2) - 0.1;
  
  // Normaliz√°ljuk a val√≥sz√≠n≈±s√©get
  bluffProbability = Math.max(0.1, Math.min(0.9, bluffProbability));
  
  // D√∂nt√©s meghozatala
  if (Math.random() < bluffProbability) {
    opponentDoubt();
  } else {
    opponentCall();
  }
}

function opponentCall() {
  const actual = calculateTotal(playerDice);
  document.getElementById("opponentRolls").textContent = `üïØÔ∏è Val√≥s √©rt√©ked: ${actual} (Dob√°said: ${playerDice.join(', ')})`;
  
  if (actual >= claimValue) {
    playerEssence++;
    document.getElementById("log").textContent += `\n\n‚úÖ Az ellenfeled elfogadja az √°ll√≠t√°sodat.\n\nIgazat mondt√°l! +1 l√©lek esszencia neked.\n\nAz ellenf√©l √≠gy gondolkodott: "Ez az √©rt√©k val√≥sz√≠n≈±nek t≈±nik a kock√°im alapj√°n. Nem kock√°ztatok."`;
  } else {
    opponentEssence++;
    document.getElementById("log").textContent += `\n\n‚ùå Az ellenfeled elhiszi az √°ll√≠t√°sodat.\n\nSikeresen bl√∂ff√∂lt√©l! De a D√©mon √©szrevette a hazugs√°got √©s 1 l√©lek esszenci√°t adott az ellenfelednek.\n\nAz ellenf√©l √≠gy gondolkodott: "Ezt az √©rt√©ket re√°lisnak tal√°lom. Elfogadom."`;
  }
  
  endRound();
}

function opponentDoubt() {
  const actual = calculateTotal(playerDice);
  document.getElementById("opponentRolls").textContent = `üïØÔ∏è Val√≥s √©rt√©ked: ${actual} (Dob√°said: ${playerDice.join(', ')})`;
  
  if (actual >= claimValue) {
    playerEssence++;
    document.getElementById("log").textContent += `\n\nüß† Ellenfeled k√©ts√©gbe vonja az √°ll√≠t√°sodat!\n\nDe igazad volt! +1 l√©lek esszencia neked.\n\nAz ellenf√©l √≠gy gondolkodott: "Ez t√∫l magas √©rt√©knek t≈±nik... kock√°ztatok √©s bl√∂ff√∂t h√≠vok!"`;
  } else {
    opponentEssence++;
    document.getElementById("log").textContent += `\n\nüîÆ Ellenfeled √°tl√°t a bl√∂ff√∂d√∂n!\n\n+1 l√©lek esszencia neki.\n\nAz ellenf√©l √≠gy gondolkodott: "Ez az √©rt√©k t√∫l magas ahhoz k√©pest, amit a kock√°im mutatnak. Biztos bl√∂ff√∂l!"`;
  }
  
  endRound();
}

function updateStatus() {
  document.getElementById("status").innerHTML = `
    üåë L√©lek esszenci√°k: <br>
    üë§ J√°t√©kos: <span class="essence-count">${playerEssence} / 5</span> &nbsp;&nbsp;&nbsp;
    üåí S√∂t√©t Ellenf√©l: <span class="essence-count">${opponentEssence} / 5</span>
  `;
}

function endRound() {
  // Megmutatjuk az ellenf√©l kock√°it
  const opponentTotal = calculateTotal(opponentDice);
  document.getElementById("opponentRolls").textContent += `\n‚ú® Ellenfeled kock√°i: [${opponentDice.join(', ')}] (√ârt√©k: ${opponentTotal})`;
  
  updateStatus();
  
  if (playerEssence >= 5) {
    document.getElementById("log").textContent += `\n\nüïØÔ∏èüïØÔ∏è Megid√©zted a V√©gzet D√©mon√°t! Az √∂t esszencia egyes√ºlt, √©s a vil√°gok k√∂z√∂tti f√°tyol felhasadt. Gy≈ëzelem!`;
    document.getElementById("actions").innerHTML = `<button onclick="resetGame()">üîÅ √öj j√°t√©k</button>`;
  } else if (opponentEssence >= 5) {
    document.getElementById("log").textContent += `\n\nüíÄ Az ellenfeled gy≈±jt√∂tt √∂ssze √∂t esszenci√°t... A D√©mon √°tk√°nak s√∫lya alatt √∂sszeroskadsz. Vesztett√©l.`;
    document.getElementById("actions").innerHTML = `<button onclick="resetGame()">üîÅ √öj j√°t√©k</button>`;
  } else {
    setTimeout(() => {
      document.getElementById("actions").innerHTML = `<button onclick="playerRoll()">üé≤ K√∂vetkez≈ë k√∂r</button>`;
    }, 1000);
  }
}

function resetGame() {
  playerEssence = 0;
  opponentEssence = 0;
  playerDice = [];
  opponentDice = [];
  gameHistory = [];
  currentRound = 0;
  
  document.getElementById("playerRolls").textContent = "";
  document.getElementById("opponentRolls").textContent = "";
  document.getElementById("log").textContent = "Az √°rnyak k√∂z√∂tt √∫j kih√≠v√°s v√°r. Dobj√°l a kock√°kkal, hogy kezdet√©t vegye az √∫j pr√≥ba.";
  updateStatus();
  document.getElementById("actions").innerHTML = `<button onclick="playerRoll()">üé≤ Dob√°s</button>`;
}

resetGame();
</script>

</body>
</html>
