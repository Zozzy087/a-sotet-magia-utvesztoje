<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>√Årny√©ktr√≥nok: Hitszeg≈ëk P√°rbaja</title>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
  <style>
    body {
      background: #0e0e0e;
      color: #eee;
      font-family: 'Cinzel', serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 30px;
      background-image: linear-gradient(to bottom, #1e1e1e 0%, #0e0e0e 100%);
      min-height: 100vh;
      margin: 0;
    }

    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: #bb86fc;
      text-shadow: 0 0 10px rgba(187, 134, 252, 0.5);
    }

    .game-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
      margin-top: 20px;
    }

    .battlefield {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin: 20px 0;
    }

    .player-side, .enemy-side {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 15px;
      background: rgba(30, 30, 30, 0.7);
      border-radius: 15px;
      width: 45%;
      position: relative;
    }

    .active-player {
      box-shadow: 0 0 15px #bb86fc;
      border: 1px solid #bb86fc;
    }

    .card {
      width: 100px;
      height: 150px;
      background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      color: #eee;
      font-size: 2.5rem;
      position: relative;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      margin: 5px;
      user-select: none;
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.4);
    }

    .card-value {
      position: absolute;
      top: 5px;
      left: 5px;
      font-size: 1.2rem;
      color: #ddd;
    }

    .card-type {
      position: absolute;
      bottom: 5px;
      font-size: 0.8rem;
      color: #ddd;
    }

    .hand {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    .selected-card {
      box-shadow: 0 0 15px #bb86fc;
      border: 2px solid #bb86fc;
      transform: translateY(-10px);
    }

    .face-down {
      background: linear-gradient(135deg, #3a1f5e 0%, #251040 100%);
      color: transparent;
    }

    .face-down .card-value, .face-down .card-type {
      display: none;
    }

    .face-down::after {
      content: "?";
      font-size: 3rem;
      color: rgba(187, 134, 252, 0.3);
    }

    #log {
      background: rgba(30, 30, 30, 0.9);
      border: 1px solid #444;
      padding: 15px;
      margin-top: 20px;
      width: 100%;
      max-width: 800px;
      border-radius: 10px;
      height: 150px;
      overflow-y: auto;
      font-family: 'Times New Roman', serif;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .action-panel {
      margin: 20px 0;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .claim-panel, .response-panel {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    select, button {
      padding: 10px 15px;
      font-size: 1rem;
      font-family: 'Cinzel', serif;
      border-radius: 8px;
      border: none;
    }

    select {
      background: #2a2a2a;
      color: #eee;
      border: 1px solid #444;
    }

    button {
      cursor: pointer;
      background: #7f00ff;
      color: white;
      box-shadow: 0 0 10px rgba(127, 0, 255, 0.5);
      transition: all 0.2s ease-in-out;
      min-width: 150px;
    }

    button:hover {
      background: #a94bff;
      box-shadow: 0 0 15px rgba(169, 75, 255, 0.7);
      transform: translateY(-2px);
    }

    button:disabled {
      background: #444;
      box-shadow: none;
      cursor: not-allowed;
      transform: none;
    }

    .stats {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin-top: 15px;
    }

    .player-stats, .enemy-stats {
      display: flex;
      flex-direction: column;
      gap: 5px;
      align-items: center;
      padding: 10px;
      background: rgba(30, 30, 30, 0.5);
      border-radius: 10px;
      min-width: 200px;
    }

    .life-bar {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .heart {
      color: #ff5555;
      font-size: 1.5rem;
      text-shadow: 0 0 5px rgba(255, 85, 85, 0.7);
    }

    .mana {
      color: #5555ff;
      font-size: 1.5rem;
      text-shadow: 0 0 5px rgba(85, 85, 255, 0.7);
    }

    .score {
      color: #bb86fc;
      font-weight: bold;
    }

    .power-bar {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .card-count {
      font-size: 0.9rem;
      color: #aaa;
    }

    .game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      gap: 30px;
      display: none;
    }

    .game-over-message {
      font-size: 2.5rem;
      color: #bb86fc;
      text-shadow: 0 0 15px rgba(187, 134, 252, 0.8);
      text-align: center;
    }

    .reveal-animation {
      animation: reveal 1s ease-out;
    }

    @keyframes reveal {
      0% { transform: rotateY(90deg); opacity: 0; }
      100% { transform: rotateY(0); opacity: 1; }
    }

    .battlefield-card {
      margin: 0 auto;
      transform-style: preserve-3d;
    }

    .notification {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(30, 30, 30, 0.9);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #7f00ff;
      box-shadow: 0 0 20px rgba(127, 0, 255, 0.5);
      z-index: 100;
      font-size: 1.5rem;
      color: #bb86fc;
      animation: fadeIn 0.5s, fadeOut 0.5s 2.5s;
      display: none;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    .effect-highlight {
      animation: highlight 1s ease-in-out;
    }

    @keyframes highlight {
      0% { box-shadow: 0 0 5px #bb86fc; }
      50% { box-shadow: 0 0 30px #bb86fc; }
      100% { box-shadow: 0 0 5px #bb86fc; }
    }

    .card-deck {
      position: relative;
      margin-top: 10px;
      font-size: 0.9rem;
      color: #aaa;
    }

    #startButton {
      margin-top: 20px;
      font-size: 1.2rem;
      padding: 15px 30px;
    }

    .instructions {
      background: rgba(30, 30, 30, 0.7);
      padding: 20px;
      border-radius: 10px;
      max-width: 800px;
      margin: 20px auto;
      text-align: left;
      line-height: 1.5;
    }

    .instructions h2 {
      color: #bb86fc;
      margin-top: 5px;
    }

    .card-icon {
      font-size: 1.4rem;
      margin-right: 5px;
    }

    /* K√°rtyat√≠pus sz√≠nek */
    .card.warrior { border-left: 3px solid #ff5555; }
    .card.mage { border-left: 3px solid #5555ff; }
    .card.assassin { border-left: 3px solid #55ff55; }
    .card.guardian { border-left: 3px solid #ffaa55; }
    .card.betrayer { border-left: 3px solid #ff55ff; }
  </style>
</head>
<body>

  <h1>√Årny√©ktr√≥nok: Hitszeg≈ëk P√°rbaja</h1>

  <div id="startScreen">
    <div class="instructions">
      <h2>J√°t√©kszab√°lyok</h2>
      <p>Az <strong>√Årny√©ktr√≥nok: Hitszeg≈ëk P√°rbaja</strong> egy strat√©giai k√°rtyaj√°t√©k, ahol a bl√∂ff√∂l√©s √©s taktika tal√°lkozik.</p>
      
      <p><strong>C√©lod:</strong> Nyerd meg a p√°rbajt azzal, hogy elveszed az ellenfeled √∂sszes √©letpontj√°t!</p>
      
      <p><strong>J√°t√©kmenet:</strong>
      <ol>
        <li>Minden k√∂rben h√∫zol egy k√°rty√°t.</li>
        <li>V√°lassz egy k√°rty√°t a kezedb≈ël, j√°tszd ki, √©s tegy√©l egy √°ll√≠t√°st (bl√∂ff√∂lhetsz is).</li>
        <li>Az ellenfeled vagy elhiszi az √°ll√≠t√°sodat, vagy bl√∂ffnek nevezi.</li>
        <li>Az eredm√©nyt≈ël f√ºgg≈ëen √©letpontokat vesz√≠thetsz vagy szerezhetsz.</li>
      </ol>
      </p>
      
      <p><strong>K√°rtyat√≠pusok:</strong>
      <ul>
        <li><span class="card-icon">‚öîÔ∏è</span><strong>Harcos (1-10):</strong> Alap er≈ëk√°rty√°k</li>
        <li><span class="card-icon">üîÆ</span><strong>M√°gus (1-5):</strong> Speci√°lis k√©pess√©g≈± k√°rty√°k</li>
        <li><span class="card-icon">üó°Ô∏è</span><strong>Orgyilkos (1-3):</strong> Legy≈ëzhet er≈ësebb k√°rty√°kat</li>
        <li><span class="card-icon">üõ°Ô∏è</span><strong>≈êrz≈ë (1-5):</strong> V√©dekez≈ë k√°rty√°k</li>
        <li><span class="card-icon">üé≠</span><strong>√Årul√≥ (1-3):</strong> B√ºnteti azokat, akik nem h√≠vnak bl√∂ff√∂t</li>
      </ul>
      </p>
    </div>
    <button id="startButton" onclick="startGame()">J√°t√©k ind√≠t√°sa</button>
  </div>

  <div id="gameScreen" style="display: none;">
    <div class="stats">
      <div class="player-stats">
        <h3>Kalandor</h3>
        <div class="life-bar">√âleter≈ë: <span id="playerLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        <div class="power-bar">Mana: <span id="playerMana">üíéüíéüíé</span></div>
        <div class="card-count">Pakli: <span id="playerDeckCount">20</span> k√°rtya</div>
      </div>
      <div class="enemy-stats">
        <h3>S√∂t√©t Nagy√∫r</h3>
        <div class="life-bar">√âleter≈ë: <span id="enemyLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        <div class="power-bar">Mana: <span id="enemyMana">üíéüíéüíé</span></div>
        <div class="card-count">Pakli: <span id="enemyDeckCount">20</span> k√°rtya</div>
      </div>
    </div>

    <div class="game-area">
      <div class="battlefield">
        <div class="player-side" id="playerSide">
          <h3>Te</h3>
          <div id="playerBattlefield" class="battlefield-card"></div>
        </div>
        <div class="enemy-side" id="enemySide">
          <h3>Ellenf√©l</h3>
          <div id="enemyBattlefield" class="battlefield-card"></div>
        </div>
      </div>

      <div class="action-panel">
        <div class="claim-panel" id="claimPanel">
          <div>
            <label for="claimType">K√°rtyat√≠pus: </label>
            <select id="claimType">
              <option value="warrior">Harcos ‚öîÔ∏è</option>
              <option value="mage">M√°gus üîÆ</option>
              <option value="assassin">Orgyilkos üó°Ô∏è</option>
              <option value="guardian">≈êrz≈ë üõ°Ô∏è</option>
              <option value="betrayer">√Årul√≥ üé≠</option>
            </select>
          </div>
          <div>
            <label for="claimValue">Er≈ë: </label>
            <select id="claimValue">
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
              <option value="8">8</option>
              <option value="9">9</option>
              <option value="10">10</option>
            </select>
          </div>
          <button id="playCardBtn" onclick="submitClaim()">K√°rtya kij√°tsz√°sa</button>
        </div>

        <div class="response-panel" id="responsePanel" style="display:none;">
          <button id="acceptBtn" onclick="respondToClaim(true)">Elhiszem</button>
          <button id="challengeBtn" onclick="respondToClaim(false)">Bl√∂ff!</button>
        </div>
      </div>

      <div class="hand" id="playerHand"></div>
    </div>

    <div id="log"></div>
  </div>

  <div class="notification" id="notification"></div>
  
  <div class="game-over-screen" id="gameOverScreen">
    <div class="game-over-message" id="gameOverMessage"></div>
    <button onclick="resetGame()">√öj j√°t√©k</button>
  </div>

  <script>
    // J√°t√©k √°llapot
    let gameState = {
      playerLife: 3,
      enemyLife: 3,
      playerMana: 3,
      enemyMana: 3,
      currentPlayer: 'player', // 'player' vagy 'enemy'
      playerDeck: [],
      enemyDeck: [],
      playerHand: [],
      enemyHand: [],
      selectedCard: null,
      playerBattlefield: null,
      enemyBattlefield: null,
      currentClaim: null,
      gameOver: false,
      turnCount: 0,
      playerBluffHistory: [], // A j√°t√©kos bl√∂ff√∂l√©si mint√°inak k√∂vet√©se
      enemyBluffHistory: []   // Az ellenf√©l bl√∂ff√∂l√©si mint√°inak k√∂vet√©se
    };

    // K√°rty√°k defin√≠ci√≥i
    const CARD_TYPES = {
      warrior: {
        name: "Harcos",
        symbol: "‚öîÔ∏è",
        maxValue: 10,
        effect: "Nincs speci√°lis hat√°s."
      },
      mage: {
        name: "M√°gus",
        symbol: "üîÆ",
        maxValue: 5,
        effect: "Ha nem h√≠vj√°k bl√∂ffnek, +1 mana."
      },
      assassin: {
        name: "Orgyilkos",
        symbol: "üó°Ô∏è",
        maxValue: 3,
        effect: "Meg√∂li a M√°gusokat. Ha bl√∂ffnek h√≠vj√°k, elvesz 1 man√°t."
      },
      guardian: {
        name: "≈êrz≈ë",
        symbol: "üõ°Ô∏è",
        maxValue: 5,
        effect: "Ha nem h√≠vj√°k bl√∂ffnek, megv√©d 1 √©letpontot."
      },
      betrayer: {
        name: "√Årul√≥",
        symbol: "üé≠",
        maxValue: 3,
        effect: "Ha nem h√≠vj√°k bl√∂ffnek, sebez 1 √©letpontot."
      }
    };

    // Pakli k√©sz√≠t√©se
    function createDeck() {
      const deck = [];
      
      // Harcosok (1-10)
      for (let i = 1; i <= 10; i++) {
        deck.push({ type: 'warrior', value: i });
      }
      
      // M√°gusok (1-5)
      for (let i = 1; i <= 5; i++) {
        deck.push({ type: 'mage', value: i });
      }
      
      // Orgyilkosok (1-3)
      for (let i = 1; i <= 3; i++) {
        deck.push({ type: 'assassin', value: i });
      }
      
      // ≈êrz≈ëk (1-5)
      for (let i = 1; i <= 5; i++) {
        deck.push({ type: 'guardian', value: i });
      }
      
      // √Årul√≥k (1-3)
      for (let i = 1; i <= 3; i++) {
        deck.push({ type: 'betrayer', value: i });
      }
      
      return shuffleDeck([...deck]);
    }

    // Pakli kever√©se
    function shuffleDeck(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    // Egy k√°rtya h√∫z√°sa a paklib√≥l
    function drawCard(deck) {
      if (deck.length === 0) return null;
      return deck.pop();
    }

    // J√°t√©kos kez√©nek renderel√©se
    function renderPlayerHand() {
      const handElement = document.getElementById('playerHand');
      handElement.innerHTML = '';
      
      gameState.playerHand.forEach((card, index) => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.type}`;
        cardElement.dataset.index = index;
        
        const cardSymbol = CARD_TYPES[card.type].symbol;
        cardElement.innerHTML = `
          <div class="card-value">${card.value}</div>
          <div>${cardSymbol}</div>
          <div class="card-type">${CARD_TYPES[card.type].name}</div>
        `;
        
        cardElement.addEventListener('click', () => selectCard(index));
        handElement.appendChild(cardElement);
      });
    }

    // K√°rtya kiv√°laszt√°sa
    function selectCard(index) {
      // Csak a j√°t√©kos k√∂r√©ben lehet k√°rty√°t v√°lasztani
      if (gameState.currentPlayer !== 'player') return;
      
      const handElement = document.getElementById('playerHand');
      const cards = handElement.querySelectorAll('.card');
      
      // Kor√°bbi kiv√°laszt√°s t√∂rl√©se
      cards.forEach(card => card.classList.remove('selected-card'));
      
      // √öj k√°rtya kiv√°laszt√°sa
      cards[index].classList.add('selected-card');
      gameState.selectedCard = index;
      
      // A k√°rtya t√≠pusa √©s √©rt√©ke alapj√°n be√°ll√≠tjuk az √°ll√≠t√°s alap√©rtelmezett √©rt√©keit
      const card = gameState.playerHand[index];
      document.getElementById('claimType').value = card.type;
      
      // Csak azokat az √©rt√©keket jelen√≠tj√ºk meg, amelyek lehets√©gesek az adott k√°rtyat√≠pusn√°l
      const claimValueSelect = document.getElementById('claimValue');
      const maxValue = CARD_TYPES[card.type].maxValue;
      claimValueSelect.innerHTML = '';
      
      for (let i = 1; i <= 10; i++) {
        if (i <= maxValue) {
          const option = document.createElement('option');
          option.value = i;
          option.textContent = i;
          if (i === card.value) option.selected = true;
          claimValueSelect.appendChild(option);
        }
      }
    }

    // K√°rtya kij√°tsz√°sa √©s √°ll√≠t√°s
    function submitClaim() {
      if (gameState.selectedCard === null) {
        showNotification("El≈ësz√∂r v√°lassz ki egy k√°rty√°t!");
        return;
      }
      
      const claimType = document.getElementById('claimType').value;
      const claimValue = parseInt(document.getElementById('claimValue').value);
      
      // Az √°ll√≠tott k√°rtyat√≠pus √©s √©rt√©k ellen≈ërz√©se
      if (claimValue > CARD_TYPES[claimType].maxValue) {
        showNotification(`Egy ${CARD_TYPES[claimType].name} maximum ${CARD_TYPES[claimType].maxValue} √©rt√©k≈± lehet!`);
        return;
      }
      
      // K√°rtya kij√°tsz√°sa
      const card = gameState.playerHand.splice(gameState.selectedCard, 1)[0];
      gameState.playerBattlefield = card;
      
      // √Åll√≠t√°s r√∂gz√≠t√©se
      gameState.currentClaim = { type: claimType, value: claimValue };
      
      // Bl√∂ff r√∂gz√≠t√©se a t√∂rt√©nelemben
      const isBluffing = card.type !== claimType || card.value !== claimValue;
      gameState.playerBluffHistory.push({
        turnCount: gameState.turnCount,
        actualCard: { ...card },
        claim: { ...gameState.currentClaim },
        isBluffing
      });
      
      // Log √ºzenet
      logMsg(`<span style="color:#bb86fc">Te:</span> Kij√°tszottam egy ${CARD_TYPES[claimType].name} (${claimValue}) k√°rty√°t.`);
      
      // UI friss√≠t√©se
      renderBattlefield();
      renderPlayerHand();
      
      // Kiv√°laszt√°s t√∂rl√©se
      gameState.selectedCard = null;
      
      // Claim panel elrejt√©se, v√°lasz panel megjelen√≠t√©se
      document.getElementById('claimPanel').style.display = 'none';
      document.getElementById('responsePanel').style.display = 'flex';
      
      // J√°t√©kos oldala akt√≠v, ellenf√©l oldala inakt√≠v
      document.getElementById('playerSide').classList.add('active-player');
      document.getElementById('enemySide').classList.remove('active-player');
      
      // Ellenf√©l gondolkodik...
      setTimeout(() => {
        if (gameState.gameOver) return;
        
        // Az ellenf√©l d√∂nt, hogy bl√∂ffnek h√≠vja-e az √°ll√≠t√°st
        const callBluff = decideEnemyResponse();
        
        if (callBluff) {
          logMsg(`<span style="color:#ff5555">Ellenf√©l:</span> Bl√∂ff! Nem hiszem el, hogy ilyen k√°rty√°d van.`);
          // K√©sleltet√©s az olvashat√≥s√°g √©rdek√©ben
          setTimeout(() => resolveChallenge(true), 1000);
        } else {
          logMsg(`<span style="color:#ff5555">Ellenf√©l:</span> Elhiszem az √°ll√≠t√°sodat.`);
          // K√©sleltet√©s az olvashat√≥s√°g √©rdek√©ben
          setTimeout(() => resolveChallenge(false), 1000);
        }
      }, 1500);
    }

    // Az ellenf√©l v√°lasza az √°ll√≠t√°sra
    function decideEnemyResponse() {
      // Alap√©rtelmezett val√≥sz√≠n≈±s√©g a bl√∂ff h√≠v√°s√°ra
      let bluffCallProbability = 0.4;
      
      const claim = gameState.currentClaim;
      
      // Az √°ll√≠t√°s hihet≈ës√©g√©nek elemz√©se
      // 1. Magas √©rt√©k √°ll√≠t√°sa n√∂veli a bl√∂ff√∂l√©s gyan√∫j√°t
      if (claim.value > 8) bluffCallProbability += 0.2;
      if (claim.type === 'warrior' && claim.value > 7) bluffCallProbability += 0.1;
      
      // 2. K√ºl√∂n√∂sen er≈ës k√°rty√°k √°ll√≠t√°sa n√∂veli a gyan√∫t
      if (claim.type === 'betrayer' && claim.value === 3) bluffCallProbability += 0.25;
      if (claim.type === 'assassin' && claim.value === 3) bluffCallProbability += 0.2;
      
      // 3. J√°t√©kos m√∫ltbeli bl√∂ff√∂l√©si szok√°sainak elemz√©se
      if (gameState.playerBluffHistory.length >= 3) {
        // Az utols√≥ 3 k√∂r vizsg√°lata
        const recentHistory = gameState.playerBluffHistory.slice(-3);
        
        // Ha a j√°t√©kos gyakran bl√∂ff√∂l
        const recentBluffs = recentHistory.filter(h => h.isBluffing).length;
        if (recentBluffs >= 2) bluffCallProbability += 0.2;
        
        // Ha a j√°t√©kos sosem bl√∂ff√∂l
        if (recentBluffs === 0) bluffCallProbability -= 0.15;
        
        // Ha a j√°t√©kos egy adott mint√°t k√∂vet (pl. minden 2. k√∂rben bl√∂ff√∂l)
        // Ez egy p√©lda, de sokkal komplexebb mint√°kat is elemezhetn√©nk
        if (gameState.playerBluffHistory.length >= 5) {
          const pattern = gameState.playerBluffHistory.slice(-5).map(h => h.isBluffing ? 1 : 0);
          if (pattern.join('') === '10101' || pattern.join('') === '01010') {
            bluffCallProbability += 0.3; // Felismerte a mint√°t
          }
        }
      }
      
      // 4. A j√°t√©k √°ll√°s√°nak figyelembev√©tele
      // Ha az ellenf√©l veszt√©sre √°ll, nagyobb kock√°zatot v√°llal
      if (gameState.enemyLife === 1 && gameState.playerLife > 1) {
        bluffCallProbability += 0.2;
      }
      
      // Ha az ellenf√©l nyer√©sre √°ll, √≥vatosabb
      if (gameState.enemyLife > gameState.playerLife) {
        bluffCallProbability -= 0.1;
      }
      
      // Kiss√© random elem hozz√°ad√°sa, hogy ne legyen teljesen megj√≥solhat√≥
      bluffCallProbability += (Math.random() * 0.2) - 0.1;
      
      // 0-1 tartom√°nyba szor√≠t√°s
      bluffCallProbability = Math.max(0, Math.min(1, bluffCallProbability));
      
      // D√∂nt√©s a bl√∂ff h√≠v√°s√°r√≥l a kisz√°m√≠tott val√≥sz√≠n≈±s√©g alapj√°n
      return Math.random() < bluffCallProbability;
    }

    // A j√°t√©kos v√°lasza az ellenf√©l √°ll√≠t√°s√°ra
    function respondToClaim(accept) {
      document.getElementById('responsePanel').style.display = 'none';
      
      if (accept) {
        logMsg(`<span style="color:#bb86fc">Te:</span> Elhiszem az √°ll√≠t√°st.`);
        resolveChallenge(false);
      } else {
        logMsg(`<span style="color:#bb86fc">Te:</span> Bl√∂ff! Nem hiszem el az √°ll√≠t√°st.`);
        resolveChallenge(true);
      }
    }

    // A kih√≠v√°s eredm√©ny√©nek ki√©rt√©kel√©se
    function resolveChallenge(challenged) {
      // K√°rty√°k felfed√©se
      revealCards();
      
      const battlefield = gameState.currentPlayer === 'player' 
        ? gameState.playerBattlefield 
        : gameState.enemyBattlefield;
      
      const claim = gameState.currentClaim;
      const isBluff = battlefield.type !== claim.type || battlefield.value !== claim.value;
      
      if (challenged) {
        // Bl√∂ff√∂l√©s eset√©n
        if (isBluff) {
          // A bl√∂ff√∂l≈ët elkapt√°k
          if (gameState.currentPlayer === 'player') {
            logMsg(`Lebuktattak! A k√°rty√°d val√≥j√°ban egy ${CARD_TYPES[battlefield.type].name} (${battlefield.value}).`);
            damage('player');
            
            // Orgyilkos speci√°lis k√©pess√©g: ha bl√∂ffnek h√≠vj√°k, elvesz 1 man√°t
            if (battlefield.type === 'assassin') {
              logMsg(`Az Orgyilkos k√©pess√©ge: Az ellenf√©l vesz√≠t 1 man√°t.`);
              useMana('enemy');
            }
          } else {
            logMsg(`Elfogtad a bl√∂ff√∂t! Az ellenf√©l k√°rty√°ja val√≥j√°ban egy ${CARD_TYPES[battlefield.type].name} (${battlefield.value}).`);
            damage('enemy');
            
            // Orgyilkos speci√°lis k√©pess√©g: ha bl√∂ffnek h√≠vj√°k, elvesz 1 man√°t
            if (battlefield.type === 'assassin') {
              logMsg(`Az Orgyilkos k√©pess√©ge: Elvesz√≠tesz 1 man√°t.`);
              useMana('player');
            }
          }
        } else {
          // A k√°rtya val√≥di volt, a kih√≠v√≥ vesz√≠t
          if (gameState.currentPlayer === 'player') {
            logMsg(`Az √°ll√≠t√°sod igaz volt! Az ellenf√©l vesz√≠t 1 √©letpontot.`);
            damage('enemy');
          } else {
            logMsg(`Az ellenf√©l igazat mondott! Vesz√≠tesz 1 √©letpontot.`);
            damage('player');
          }
        }
      } else {
        // Elfogad√°s eset√©n speci√°lis k√©pess√©gek
        const cardEffects = processCardEffects(battlefield.type, gameState.currentPlayer);
        
        // J√°t√©k k√∂vetkez≈ë √°ll√°sa
        nextTurn();
      }
    }

    // K√°rty√°k speci√°lis k√©pess√©geinek feldolgoz√°sa
    function processCardEffects(cardType, player) {
      const opponent = player === 'player' ? 'enemy' : 'player';
      
      switch (cardType) {
        case 'mage':
          // M√°gus: +1 mana
          logMsg(`${player === 'player' ? 'A' : 'Az ellenf√©l'} M√°gus k√©pess√©ge: +1 mana`);
          addMana(player);
          break;
        
        case 'guardian':
          // ≈êrz≈ë: V√©d 1 √©letpontot
          logMsg(`${player === 'player' ? 'A' : 'Az ellenf√©l'} ≈êrz≈ë k√©pess√©ge: V√©d 1 √©letpontot k√∂vetkez≈ë sebz√©sn√©l`);
          // Ezt k√©s≈ëbb lehet implement√°lni, ha szeretn√©nk
          break;
        
        case 'betrayer':
          // √Årul√≥: Sebez 1 √©letpontot
          logMsg(`${player === 'player' ? 'A' : 'Az ellenf√©l'} √Årul√≥ k√©pess√©ge: 1 √©letpontot sebez`);
          damage(opponent);
          break;
      }
    }

    // A csata mez≈ëj√©nek renderel√©se
    function renderBattlefield() {
      const playerBattlefieldElement = document.getElementById('playerBattlefield');
      const enemyBattlefieldElement = document.getElementById('enemyBattlefield');
      
      playerBattlefieldElement.innerHTML = '';
      enemyBattlefieldElement.innerHTML = '';
      
      if (gameState.playerBattlefield) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${gameState.playerBattlefield.type} face-down`;
        
        if (gameState.currentPlayer !== 'player') {
          // Ha az ellenf√©l k√∂re van, a j√°t√©kos k√°rty√°ja l√°that√≥
          cardElement.classList.remove('face-down');
          const cardSymbol = CARD_TYPES[gameState.playerBattlefield.type].symbol;
          cardElement.innerHTML = `
            <div class="card-value">${gameState.playerBattlefield.value}</div>
            <div>${cardSymbol}</div>
            <div class="card-type">${CARD_TYPES[gameState.playerBattlefield.type].name}</div>
          `;
        }
        
        playerBattlefieldElement.appendChild(cardElement);
      }
      
      if (gameState.enemyBattlefield) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${gameState.enemyBattlefield.type} face-down`;
        
        if (gameState.currentPlayer === 'enemy' && gameState.enemyBattlefield.revealed) {
          // Ha az ellenf√©l k√∂re van √©s a k√°rty√°t m√°r felfedt√©k
          cardElement.classList.remove('face-down');
          const cardSymbol = CARD_TYPES[gameState.enemyBattlefield.type].symbol;
          cardElement.innerHTML = `
            <div class="card-value">${gameState.enemyBattlefield.value}</div>
            <div>${cardSymbol}</div>
            <div class="card-type">${CARD_TYPES[gameState.enemyBattlefield.type].name}</div>
          `;
        }
        
        enemyBattlefieldElement.appendChild(cardElement);
      }
    }

    // K√°rty√°k felfed√©se a csatat√©ren
    function revealCards() {
      if (gameState.playerBattlefield) {
        const playerBattlefieldCard = document.querySelector('#playerBattlefield .card');
        if (playerBattlefieldCard) {
          playerBattlefieldCard.classList.remove('face-down');
          playerBattlefieldCard.classList.add('reveal-animation');
          
          const cardSymbol = CARD_TYPES[gameState.playerBattlefield.type].symbol;
          playerBattlefieldCard.innerHTML = `
            <div class="card-value">${gameState.playerBattlefield.value}</div>
            <div>${cardSymbol}</div>
            <div class="card-type">${CARD_TYPES[gameState.playerBattlefield.type].name}</div>
          `;
        }
      }
      
      if (gameState.enemyBattlefield) {
        const enemyBattlefieldCard = document.querySelector('#enemyBattlefield .card');
        if (enemyBattlefieldCard) {
          enemyBattlefieldCard.classList.remove('face-down');
          enemyBattlefieldCard.classList.add('reveal-animation');
          
          const cardSymbol = CARD_TYPES[gameState.enemyBattlefield.type].symbol;
          enemyBattlefieldCard.innerHTML = `
            <div class="card-value">${gameState.enemyBattlefield.value}</div>
            <div>${cardSymbol}</div>
            <div class="card-type">${CARD_TYPES[gameState.enemyBattlefield.type].name}</div>
          `;
        }
      }
    }

    // √âletpont sebz√©se
    function damage(player) {
      if (player === 'player') {
        gameState.playerLife--;
      } else {
        gameState.enemyLife--;
      }
      
      updateStats();
      
      // Game over ellen≈ërz√©se
      if (gameState.playerLife <= 0) {
        gameOver('enemy');
      } else if (gameState.enemyLife <= 0) {
        gameOver('player');
      }
    }

    // Mana hozz√°ad√°sa
    function addMana(player) {
      if (player === 'player') {
        gameState.playerMana = Math.min(gameState.playerMana + 1, 5);
      } else {
        gameState.enemyMana = Math.min(gameState.enemyMana + 1, 5);
      }
      
      updateStats();
    }

    // Mana felhaszn√°l√°sa
    function useMana(player) {
      if (player === 'player' && gameState.playerMana > 0) {
        gameState.playerMana--;
      } else if (player === 'enemy' && gameState.enemyMana > 0) {
        gameState.enemyMana--;
      }
      
      updateStats();
    }

    // Statisztik√°k friss√≠t√©se
    function updateStats() {
      document.getElementById('playerLives').textContent = '‚ù§Ô∏è'.repeat(gameState.playerLife);
      document.getElementById('enemyLives').textContent = '‚ù§Ô∏è'.repeat(gameState.enemyLife);
      
      document.getElementById('playerMana').textContent = 'üíé'.repeat(gameState.playerMana);
      document.getElementById('enemyMana').textContent = 'üíé'.repeat(gameState.enemyMana);
      
      document.getElementById('playerDeckCount').textContent = gameState.playerDeck.length;
      document.getElementById('enemyDeckCount').textContent = gameState.enemyDeck.length;
    }

    // J√°t√©k v√©ge
    function gameOver(winner) {
      gameState.gameOver = true;
      
      const message = winner === 'player' 
        ? "Gy≈ëzt√©l! A S√∂t√©t Nagy√∫r elbukott!"
        : "Vesztett√©l! A S√∂t√©t Nagy√∫r gy≈ëzedelmeskedett!";
      
      document.getElementById('gameOverMessage').textContent = message;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    // K√∂vetkez≈ë k√∂r
    function nextTurn() {
      gameState.turnCount++;
      
      // Csatat√©r tiszt√≠t√°sa
      gameState.playerBattlefield = null;
      gameState.enemyBattlefield = null;
      
      // J√°t√©kos v√°lt√°sa
      gameState.currentPlayer = gameState.currentPlayer === 'player' ? 'enemy' : 'player';
      
      // UI friss√≠t√©se
      renderBattlefield();
      
      // Akt√≠v oldal friss√≠t√©se
      document.getElementById('playerSide').classList.toggle('active-player', gameState.currentPlayer === 'player');
      document.getElementById('enemySide').classList.toggle('active-player', gameState.currentPlayer === 'enemy');
      
      // K√°rtya h√∫z√°sa
      if (gameState.currentPlayer === 'player') {
        // J√°t√©kos h√∫z
        const card = drawCard(gameState.playerDeck);
        if (card) gameState.playerHand.push(card);
        
        // UI friss√≠t√©se
        renderPlayerHand();
        document.getElementById('claimPanel').style.display = 'flex';
        document.getElementById('responsePanel').style.display = 'none';
        
        logMsg("A te k√∂r√∂d k√∂vetkezik. V√°lassz egy k√°rty√°t √©s tegy√©l egy √°ll√≠t√°st.");
      } else {
        // Ellenf√©l h√∫z
        const card = drawCard(gameState.enemyDeck);
        if (card) gameState.enemyHand.push(card);
        
        // Ellenf√©l l√©p
        document.getElementById('claimPanel').style.display = 'none';
        document.getElementById('responsePanel').style.display = 'none';
        
        logMsg("Az ellenf√©l k√∂re k√∂vetkezik...");
        
        // Kis k√©sleltet√©s, hogy az ellenf√©l "gondolkodjon"
        setTimeout(() => {
          if (gameState.gameOver) return;
          enemyPlayCard();
        }, 1500);
      }
      
      updateStats();
    }

    // Az ellenf√©l k√°rty√°j√°nak kij√°tsz√°sa
    function enemyPlayCard() {
      if (gameState.enemyHand.length === 0) {
        logMsg("Az ellenf√©lnek nincs t√∂bb k√°rty√°ja!");
        return;
      }
      
      // Az ellenf√©l strat√©gi√°ja a j√°t√©k √°ll√°sa alapj√°n
      const cardIndex = determineEnemyCardIndex();
      const card = gameState.enemyHand.splice(cardIndex, 1)[0];
      gameState.enemyBattlefield = card;
      
      // Az ellenf√©l √°ll√≠t√°sa
      const claim = determineEnemyClaim(card);
      gameState.currentClaim = claim;
      
      // Bl√∂ff r√∂gz√≠t√©se a t√∂rt√©nelemben
      const isBluffing = card.type !== claim.type || card.value !== claim.value;
      gameState.enemyBluffHistory.push({
        turnCount: gameState.turnCount,
        actualCard: { ...card },
        claim: { ...claim },
        isBluffing
      });
      
      logMsg(`<span style="color:#ff5555">Ellenf√©l:</span> Kij√°tszottam egy ${CARD_TYPES[claim.type].name} (${claim.value}) k√°rty√°t.`);
      
      // UI friss√≠t√©se
      renderBattlefield();
      
      // V√°lasz panel megjelen√≠t√©se a j√°t√©kosnak
      document.getElementById('responsePanel').style.display = 'flex';
    }

    // Az ellenf√©l k√°rtyav√°laszt√°sa
    function determineEnemyCardIndex() {
      // Alap√©rtelmezetten v√©letlenszer≈± v√°laszt√°s
      const randomIndex = Math.floor(Math.random() * gameState.enemyHand.length);
      
      // Ha a j√°t√©kos √©letpontja nagyon alacsony, pr√≥b√°ljunk olyan k√°rty√°t v√°lasztani, ami direkt sebez
      if (gameState.playerLife === 1) {
        const betrayerIndex = gameState.enemyHand.findIndex(card => card.type === 'betrayer');
        if (betrayerIndex >= 0) return betrayerIndex;
      }
      
      // Ha az ellenf√©l mana n√©lk√ºl van, pr√≥b√°ljunk M√°gust j√°tszani
      if (gameState.enemyMana === 0) {
        const mageIndex = gameState.enemyHand.findIndex(card => card.type === 'mage');
        if (mageIndex >= 0) return mageIndex;
      }
      
      // Egy√©bk√©nt maradunk a v√©letlenszer≈± v√°laszt√°sn√°l, ami kisz√°m√≠thatatlanabb√° teszi az ellenfelet
      return randomIndex;
    }

    // Az ellenf√©l √°ll√≠t√°s√°nak meghat√°roz√°sa
    function determineEnemyClaim(card) {
      // Bl√∂ff√∂l√©si hajland√≥s√°g - kezdetben 30% es√©ly
      let bluffProbability = 0.3;
      
      // Ha az ellenf√©l veszt√©sre √°ll, n√∂velj√ºk a bl√∂ff√∂l√©s es√©ly√©t
      if (gameState.enemyLife < gameState.playerLife) {
        bluffProbability += 0.2;
      }
      
      // Ha a j√°t√©kos sosem h√≠v bl√∂ff√∂t, akkor n√∂velj√ºk a bl√∂ff√∂l√©s es√©ly√©t
      if (gameState.playerBluffHistory.length >= 3) {
        const recentHistory = gameState.playerBluffHistory.slice(-3);
        const neverChallenges = !recentHistory.some(h => h.isBluffing);
        if (neverChallenges) bluffProbability += 0.2;
      }
      
      // Ha a k√°rtya gyenge, nagyobb es√©ly a bl√∂ff√∂l√©sre
      if (card.value < 3 && card.type === 'warrior') {
        bluffProbability += 0.2;
      }
      
      // Kisz√°m√≠thatatlans√°g hozz√°ad√°sa
      bluffProbability += (Math.random() * 0.2) - 0.1;
      bluffProbability = Math.max(0, Math.min(1, bluffProbability));
      
      // D√∂nt√©s a bl√∂ff√∂l√©sr≈ël
      const willBluff = Math.random() < bluffProbability;
      
      if (!willBluff) {
        // Igazmond√°s - a t√©nyleges k√°rty√°t mondjuk be
        return { type: card.type, value: card.value };
      } else {
        // Bl√∂ff√∂l√©s - valami m√°st mondunk
        
        // Strat√©gi√°k a bl√∂ff√∂l√©shez
        
        // 1. Er≈ës k√°rty√°t mondani
        if (Math.random() < 0.6) {
          // Magas √©rt√©k≈± Harcos vagy ≈êrz≈ë
          const strongType = Math.random() < 0.5 ? 'warrior' : 'guardian';
          const highValue = Math.min(CARD_TYPES[strongType].maxValue, 7 + Math.floor(Math.random() * 4));
          return { type: strongType, value: highValue };
        }
        
        // 2. Speci√°lis k√©pess√©g≈± k√°rty√°t mondani
        else {
          const specialTypes = ['mage', 'assassin', 'betrayer'];
          const chosenType = specialTypes[Math.floor(Math.random() * specialTypes.length)];
          const value = 1 + Math.floor(Math.random() * CARD_TYPES[chosenType].maxValue);
          return { type: chosenType, value };
        }
      }
    }

    // Log √ºzenet
    function logMsg(message) {
      const log = document.getElementById('log');
      const messageElement = document.createElement('div');
      messageElement.innerHTML = message;
      log.appendChild(messageElement);
      log.scrollTop = log.scrollHeight;
    }

    // √ârtes√≠t√©s megjelen√≠t√©se
    function showNotification(message) {
      const notification = document.getElementById('notification');
      notification.textContent = message;
      notification.style.display = 'block';
      
      setTimeout(() => {
        notification.style.display = 'none';
      }, 3000);
    }

    // J√°t√©k ind√≠t√°sa
    function startGame() {
      document.getElementById('startScreen').style.display = 'none';
      document.getElementById('gameScreen').style.display = 'block';
      
      resetGame();
    }

    // J√°t√©k √∫jraind√≠t√°sa
    function resetGame() {
      // J√°t√©k √°llapot vissza√°ll√≠t√°sa
      gameState = {
        playerLife: 3,
        enemyLife: 3,
        playerMana: 3,
        enemyMana: 3,
        currentPlayer: 'player',
        playerDeck: createDeck(),
        enemyDeck: createDeck(),
        playerHand: [],
        enemyHand: [],
        selectedCard: null,
        playerBattlefield: null,
        enemyBattlefield: null,
        currentClaim: null,
        gameOver: false,
        turnCount: 0,
        playerBluffHistory: [],
        enemyBluffHistory: []
      };
      
      // Kezd≈ë k√°rty√°k h√∫z√°sa
      for (let i = 0; i < 5; i++) {
        gameState.playerHand.push(drawCard(gameState.playerDeck));
        gameState.enemyHand.push(drawCard(gameState.enemyDeck));
      }
      
      // UI friss√≠t√©se
      renderPlayerHand();
      renderBattlefield();
      updateStats();
      
      // Log tiszt√≠t√°sa
      document.getElementById('log').innerHTML = '';
      logMsg("A j√°t√©k elkezd≈ëd√∂tt! V√°lassz egy k√°rty√°t √©s tegy√©l egy √°ll√≠t√°st.");
      
      // Kezd≈ëpanelek be√°ll√≠t√°sa
      document.getElementById('claimPanel').style.display = 'flex';
      document.getElementById('responsePanel').style.display = 'none';
      
      // Game over k√©perny≈ë elrejt√©se
      document.getElementById('gameOverScreen').style.display = 'none';
      
      // Akt√≠v j√°t√©kos jel√∂l√©se
      document.getElementById('playerSide').classList.add('active-player');
      document.getElementById('enemySide').classList.remove('active-player');
    }
  </script>

</body>
</html>
