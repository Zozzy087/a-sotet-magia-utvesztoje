<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Isteni Kockajáték - Hazudós Kockapóker</title>
  <link href="https://fonts.googleapis.com/css2?family=Eczar:wght@400..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: "Eczar", serif;
      background-image: url('images/background.jpg.jpg');
      background-size: cover;
      background-position: center;
      color: #d1c3af;
      margin: 0;
      padding: 20px;
      text-align: center;
      background-color: #0c0c0c;
    }
    h1 {
      font-size: 2.6rem;
      margin-bottom: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      display: inline-block;
      text-shadow: 0 0 10px #ff6400;
      letter-spacing: 2px;
    }
    #gameArea {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 30px;
      margin: 20px 0;
    }
    .player-section {
      background-color: rgba(20, 14, 10, 0.85);
      padding: 20px;
      border-radius: 5px;
      min-width: 260px;
      border: 1px solid #482c17;
      transition: all 0.3s ease;
      position: relative;
    }
    .active-player {
      border: 3px solid #ff6400;
      box-shadow: 0 0 25px rgba(255, 100, 0, 0.7);
      transform: scale(1.05);
      z-index: 2;
    }
    .active-player::before {
      content: "》";
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2.5rem;
      color: #ff6400;
      text-shadow: 0 0 10px #ff6400;
      animation: pulse 1.5s infinite;
    }
    .active-player::after {
      content: "《";
      position: absolute;
      right: -30px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2.5rem;
      color: #ff6400;
      text-shadow: 0 0 10px #ff6400;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    h2 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #d1c3af;
    }
    .sparks-container {
      margin: 15px 0;
    }
    .spark {
      color: #ff6400;
      font-size: 2rem;
      margin: 0 5px;
      text-shadow: 0 0 10px rgba(255, 100, 0, 0.7);
    }
    .lost-spark {
      color: #482c17;
      text-shadow: none;
    }
    .dice-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 20px 0;
      flex-wrap: wrap;
      min-height: 80px;
    }
    .die {
      width: 60px;
      height: 60px;
      background-color: #291d14;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: #d1c3af;
      box-shadow: 0 0 15px rgba(255, 100, 0, 0.3);
      transition: all 0.3s ease;
    }
    .rolling {
      animation: rollDice 0.8s ease-out;
    }
    @keyframes rollDice {
      0% { transform: rotateY(0deg) rotateX(0deg); }
      50% { transform: rotateY(720deg) rotateX(360deg); }
      100% { transform: rotateY(1440deg) rotateX(720deg); }
    }
    #announce-container {
      background-color: rgba(20, 14, 10, 0.85);
      padding: 15px;
      border-radius: 5px;
      margin: 20px auto;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .combo-selector {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
    }
    .combo-option {
      background-color: rgba(72, 44, 23, 0.6);
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid transparent;
    }
    .combo-option:hover, .combo-option.selected {
      background-color: rgba(255, 100, 0, 0.3);
      border-color: #ff6400;
    }
    .combo-option img {
      width: 140px;
      height: 40px;
      object-fit: contain;
    }
    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }
    button {
      font-family: "Eczar", serif;
      font-size: 1.1rem;
      padding: 12px 20px;
      margin: 5px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background-color: #482c17;
      color: #d1c3af;
      box-shadow: 0 0 10px rgba(255, 100, 0, 0.3);
      transition: all 0.3s;
      letter-spacing: 1px;
      min-width: 120px;
    }
    button:hover:not(:disabled) {
      background-color: #5a381f;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 100, 0, 0.5);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    #result {
      font-size: 1.3rem;
      background-color: rgba(20, 14, 10, 0.7);
      padding: 15px;
      border-radius: 5px;
      display: inline-block;
      margin-top: 20px;
      max-width: 80%;
      letter-spacing: 1px;
      line-height: 1.4;
    }
    #game-log {
      background-color: rgba(20, 14, 10, 0.7);
      padding: 10px;
      border-radius: 5px;
      margin-top: 20px;
      max-height: 150px;
      overflow-y: auto;
      text-align: left;
      width: 80%;
      margin-left: auto;
      margin-right: auto;
    }
    .log-entry {
      margin: 5px 0;
      font-size: 0.9rem;
      color: #a09080;
    }
    #ability-panel {
      background-color: rgba(20, 14, 10, 0.85);
      padding: 15px;
      border-radius: 5px;
      margin: 20px auto;
      max-width: 600px;
      display: none;
    }
    .ability-title {
      color: #ff6400;
      font-size: 1.3rem;
      margin-bottom: 10px;
    }
    .ability-description {
      margin-bottom: 15px;
    }
    .rules-panel {
      background-color: rgba(20, 14, 10, 0.85);
      padding: 15px;
      border-radius: 5px;
      margin: 20px auto;
      max-width: 800px;
      text-align: left;
    }
    .rules-panel h3 {
      color: #ff6400;
      border-bottom: 1px solid #ff6400;
      padding-bottom: 5px;
    }
    .rules-panel ul {
      padding-left: 20px;
    }
    .rules-panel li {
      margin: 8px 0;
    }
    .hidden {
      display: none;
    }
    .combo-tooltip {
      position: relative;
      display: inline-block;
    }
    .combo-tooltip .tooltiptext {
      visibility: hidden;
      width: 200px;
      background-color: #291d14;
      color: #d1c3af;
      text-align: center;
      border-radius: 5px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      font-size: 0.9rem;
    }
    .combo-tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    #resetContainer {
      display: none;
      margin-top: 30px;
    }
    .winner {
      color: #ff6400;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(255, 100, 0, 0.7);
    }
  </style>
</head>
<body>

<h1>Isteni Kockajáték - Hazudós Kockapóker</h1>

<div class="rules-panel">
  <h3>Játékszabályok</h3>
  <p>Mindkét játékos 5 "isteni szikrával" (életponttal) kezd. Dobj 5 kockával, majd jelents be egy kombinációt (vagy blöffölj).</p>
  
  <h3>Kombinációk</h3>
  <ul>
    <li><strong>Három egyforma</strong> - Képesség: Meglesheted az ellenfél következő dobását</li>
    <li><strong>Full house</strong> (Három egyforma + két egyforma) - Képesség: Ha nem hiszik el, és igazat mondtál, az ellenfél 2 szikrát veszít</li>
    <li><strong>Négy egyforma</strong> - Képesség: Védelmet kapsz egy isteni szikra elvesztése ellen</li>
    <li><strong>Öt egyforma</strong> - Képesség: Visszaszerezhetsz egy elvesztett isteni szikrát</li>
  </ul>
  
  <h3>Kör menete</h3>
  <ol>
    <li>Az aktív játékos dob és bejelent egy kombinációt (vagy blöfföl)</li>
    <li>Az ellenfél dönt: elhiszi vagy leleplezi</li>
    <li>Ha elhiszi: ő jön, és nagyobb értéket kell bejelentenie</li>
    <li>Ha leleplezi és a bejelentés hamis: a bejelentő veszít egy szikrát</li>
    <li>Ha leleplezi és a bejelentés igaz: a leleplező veszít egy (vagy több) szikrát</li>
  </ol>
  
  <h3>Rangsor (növekvő erősség)</h3>
  <p>Három egyforma < Full house < Négy egyforma < Öt egyforma</p>
  <p>Egyenló kombinációknál a nagyobb értékű kocka erősebb (pl. három 6-os > három 5-ös)</p>
</div>

<div id="gameArea">
  <div id="playerSection" class="player-section active-player">
    <h2>Kalandor</h2>
    <div class="sparks-container" id="playerSparks">
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
    </div>
    <div class="dice-container" id="playerDice"></div>
  </div>
  
  <div id="botSection" class="player-section">
    <h2>Sötét Nagyúr</h2>
    <div class="sparks-container" id="botSparks">
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
      <i class="fas fa-fire spark"></i>
    </div>
    <div class="dice-container" id="botDice"></div>
  </div>
</div>

<div id="announce-container">
  <h3 id="announce-title">Válaszd ki a bejelentendő kombinációt</h3>
  <div class="combo-selector" id="combo-selector">
    <div class="combo-option combo-tooltip" data-combo="three" data-dice-value="1">
      <span class="tooltiptext">Három egyforma (1-es)</span>
      <div class="combo-display">
        <i class="fas fa-dice-one" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice-one" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice-one" style="font-size: 1.5rem;"></i>
        <span> + </span>
        <i class="fas fa-dice" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice" style="font-size: 1.5rem;"></i>
      </div>
    </div>
    <div class="combo-option combo-tooltip" data-combo="three" data-dice-value="2">
      <span class="tooltiptext">Három egyforma (2-es)</span>
      <div class="combo-display">
        <i class="fas fa-dice-two" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice-two" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice-two" style="font-size: 1.5rem;"></i>
        <span> + </span>
        <i class="fas fa-dice" style="font-size: 1.5rem;"></i>
        <i class="fas fa-dice" style="font-size: 1.5rem;"></i>
      </div>
    </div>
    <!-- További combo opciók... -->
  </div>
  <div class="action-buttons" id="action-buttons">
    <button id="roll-btn">Dobás</button>
    <button id="announce-btn" disabled>Bejelentés</button>
    <button id="believe-btn" disabled>Elhiszem</button>
    <button id="doubt-btn" disabled>Kétségbe vonom</button>
  </div>
</div>

<div id="ability-panel">
  <div class="ability-title" id="ability-title">Képesség aktiválva!</div>
  <div class="ability-description" id="ability-description"></div>
  <div class="action-buttons">
    <button id="use-ability-btn">Használom</button>
    <button id="skip-ability-btn">Kihagyom</button>
  </div>
</div>

<div id="result">Üdvözöllek a Kockajátékban! Dobj a kockákkal a kezdéshez.</div>

<div id="game-log"></div>

<div id="resetContainer">
  <button onclick="startGame()">Új Játék</button>
</div>

<script>
// Játék állapot és változók
let gameState = {
  playerSparks: 5,
  botSparks: 5,
  playerDice: [],
  botDice: [],
  activePlayer: 'player', // 'player' vagy 'bot'
  lastAnnouncement: null,
  currentPhase: 'roll', // 'roll', 'announce', 'respond', 'ability'
  playerAbilities: {
    shield: false,
    peek: false
  },
  botAbilities: {
    shield: false,
    peek: false
  },
  gameHistory: []
};

// Konstansok és segédfüggvények
const DICE_FACES = 6;
const COMBINATIONS = {
  'three': {name: 'Három egyforma', rank: 1, ability: 'peek'},
  'fullhouse': {name: 'Full house', rank: 2, ability: 'double'},
  'four': {name: 'Négy egyforma', rank: 3, ability: 'shield'},
  'five': {name: 'Öt egyforma', rank: 4, ability: 'heal'}
};

// DOM elemek
const playerDiceContainer = document.getElementById('playerDice');
const botDiceContainer = document.getElementById('botDice');
const playerSparksContainer = document.getElementById('playerSparks');
const botSparksContainer = document.getElementById('botSparks');
const playerSection = document.getElementById('playerSection');
const botSection = document.getElementById('botSection');
const comboSelector = document.getElementById('combo-selector');
const announceBtn = document.getElementById('announce-btn');
const rollBtn = document.getElementById('roll-btn');
const believeBtn = document.getElementById('believe-btn');
const doubtBtn = document.getElementById('doubt-btn');
const resultDisplay = document.getElementById('result');
const gameLog = document.getElementById('game-log');
const abilityPanel = document.getElementById('ability-panel');
const abilityTitle = document.getElementById('ability-title');
const abilityDescription = document.getElementById('ability-description');
const useAbilityBtn = document.getElementById('use-ability-btn');
const skipAbilityBtn = document.getElementById('skip-ability-btn');
const resetContainer = document.getElementById('resetContainer');

// Játék indítása
function startGame() {
  gameState = {
    playerSparks: 5,
    botSparks: 5,
    playerDice: [],
    botDice: [],
    activePlayer: 'player',
    lastAnnouncement: null,
    currentPhase: 'roll',
    playerAbilities: {
      shield: false,
      peek: false
    },
    botAbilities: {
      shield: false,
      peek: false
    },
    gameHistory: []
  };
  
  updateUI();
  resultDisplay.textContent = 'Üdvözöllek a Kockajátékban! Dobb a kockákkal a kezdéshez.';
  resetContainer.style.display = 'none';
  clearLog();
  addLogEntry('Új játék kezdődött!');
  
  // Combo selector opciók generálása
  generateComboOptions();
}

// Kockadobás
function rollDice(count = 5) {
  const dice = [];
  for (let i = 0; i < count; i++) {
    dice.push(Math.floor(Math.random() * DICE_FACES) + 1);
  }
  return dice;
}

// Játékos dob
function playerRoll() {
  if (gameState.currentPhase !== 'roll' || gameState.activePlayer !== 'player') return;
  
  gameState.playerDice = rollDice();
  displayDice(gameState.playerDice, playerDiceContainer, true);
  
  addLogEntry('Dobtál a kockákkal.');
  
  // Elemezzük a dobott kombinációkat
  const validCombos = analyzeValidCombinations(gameState.playerDice);
  updateComboSelector(validCombos, gameState.lastAnnouncement);
  
  // Frissítjük a játék állapotát
  gameState.currentPhase = 'announce';
  updateUI();
}

// Bot dob
function botRoll() {
  if (gameState.currentPhase !== 'roll' || gameState.activePlayer !== 'bot') return;
  
  // Bot dobás rejtetten
  gameState.botDice = rollDice();
  displayDice(['?', '?', '?', '?', '?'], botDiceContainer, true);
  
  addLogEntry('A Sötét Nagyúr dobott a kockákkal.');
  
  // Bot elemzi a lehetőségeit és bejelent egy kombinációt
  setTimeout(() => botAnnounce(), 1500);
}

// Kockák megjelenítése
function displayDice(dice, container, animate = false) {
  container.innerHTML = '';
  
  dice.forEach(value => {
    const die = document.createElement('div');
    die.className = 'die';
    if (animate) die.classList.add('rolling');
    
    if (value === '?') {
      die.innerHTML = '<i class="fas fa-question"></i>';
    } else {
      die.innerHTML = getDiceIcon(value);
    }
    
    container.appendChild(die);
  });
}

// Kocka ikon lekérése
function getDiceIcon(value) {
  const icons = {
    1: '<i class="fas fa-dice-one"></i>',
    2: '<i class="fas fa-dice-two"></i>',
    3: '<i class="fas fa-dice-three"></i>',
    4: '<i class="fas fa-dice-four"></i>',
    5: '<i class="fas fa-dice-five"></i>',
    6: '<i class="fas fa-dice-six"></i>'
  };
  return icons[value] || '<i class="fas fa-dice"></i>';
}

// Kombinációk elemzése
function analyzeValidCombinations(dice) {
  const counts = {};
  dice.forEach(value => {
    counts[value] = (counts[value] || 0) + 1;
  });
  
  const result = [];
  
  // Öt egyforma
  for (let i = 1; i <= 6; i++) {
    if (counts[i] === 5) {
      result.push({combo: 'five', diceValue: i});
    }
  }
  
  // Négy egyforma
  for (let i = 1; i <= 6; i++) {
    if (counts[i] === 4) {
      result.push({combo: 'four', diceValue: i});
    }
  }
  
  // Full house
  for (let i = 1; i <= 6; i++) {
    if (counts[i] === 3) {
      for (let j = 1; j <= 6; j++) {
        if (i !== j && counts[j] === 2) {
          result.push({combo: 'fullhouse', diceValue: i});
        }
      }
    }
  }
  
  // Három egyforma
  for (let i = 1; i <= 6; i++) {
    if (counts[i] === 3) {
      result.push({combo: 'three', diceValue: i});
    }
  }
  
  return result;
}

// Kombinációk nevének formázása
function formatComboName(combo, diceValue) {
  const baseName = COMBINATIONS[combo].name;
  return `${baseName} (${diceValue}-ös)`;
}

// Combo-k rangsorolása
function rankCombination(combo, diceValue) {
  return COMBINATIONS[combo].rank * 10 + diceValue;
}

// Kombinációk összehasonlítása
function isHigherCombination(newCombo, newValue, lastCombo, lastValue) {
  const newRank = rankCombination(newCombo, newValue);
  const lastRank = rankCombination(lastCombo, lastValue);
  return newRank > lastRank;
}

// Combo selector frissítése
function updateComboSelector(validCombos, lastAnnouncement) {
  comboSelector.innerHTML = '';
  
  // Minden lehetséges kombináció generálása (1-6 értékekkel minden típushoz)
  const allPossibleCombos = [];
  
  Object.keys(COMBINATIONS).forEach(combo => {
    for (let i = 1; i <= 6; i++) {
      allPossibleCombos.push({combo, diceValue: i});
    }
  });
  
  // Rendezzük a kombinációkat rangsor szerint
  allPossibleCombos.sort((a, b) => {
    return rankCombination(a.combo, a.diceValue) - rankCombination(b.combo, b.diceValue);
  });
  
  // Szűrjük a lehetséges bejelentéseket az előző bejelentés alapján
  let filteredCombos = allPossibleCombos;
  if (lastAnnouncement) {
    filteredCombos = allPossibleCombos.filter(combo => {
      return isHigherCombination(
        combo.combo, 
        combo.diceValue, 
        lastAnnouncement.combo, 
        lastAnnouncement.diceValue
      );
    });
  }
  
  filteredCombos.forEach(comboObj => {
    const { combo, diceValue } = comboObj;
    const isValid = validCombos.some(
      validCombo => validCombo.combo === combo && validCombo.diceValue === diceValue
    );
    
    const option = document.createElement('div');
    option.className = 'combo-option combo-tooltip';
    option.dataset.combo = combo;
    option.dataset.diceValue = diceValue;
    
    // Tooltip a kombinációhoz
    const tooltip = document.createElement('span');
    tooltip.className = 'tooltiptext';
    tooltip.textContent = formatComboName(combo, diceValue);
    option.appendChild(tooltip);
    
    // Kombinációt megjelenítő div
    const comboDisplay = document.createElement('div');
    comboDisplay.className = 'combo-display';
    
    // Kockák megjelenítése a kombinációban
    if (combo === 'three') {
      for (let i = 0; i < 3; i++) {
        comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(diceValue)}" style="font-size: 1.5rem;"></i>`;
      }
      comboDisplay.innerHTML += `<span> + </span>`;
      comboDisplay.innerHTML += `<i class="fas fa-dice" style="font-size: 1.5rem;"></i>`;
      comboDisplay.innerHTML += `<i class="fas fa-dice" style="font-size: 1.5rem;"></i>`;
    } 
    else if (combo === 'fullhouse') {
      for (let i = 0; i < 3; i++) {
        comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(diceValue)}" style="font-size: 1.5rem;"></i>`;
      }
      comboDisplay.innerHTML += `<span> + </span>`;
      const otherValue = diceValue === 6 ? 1 : diceValue + 1;
      comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(otherValue)}" style="font-size: 1.5rem;"></i>`;
      comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(otherValue)}" style="font-size: 1.5rem;"></i>`;
    } 
    else if (combo === 'four') {
      for (let i = 0; i < 4; i++) {
        comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(diceValue)}" style="font-size: 1.5rem;"></i>`;
      }
      comboDisplay.innerHTML += `<span> + </span>`;
      comboDisplay.innerHTML += `<i class="fas fa-dice" style="font-size: 1.5rem;"></i>`;
    } 
    else if (combo === 'five') {
      for (let i = 0; i < 5; i++) {
        comboDisplay.innerHTML += `<i class="fas fa-dice-${getNumberWord(diceValue)}" style="font-size: 1.5rem;"></i>`;
      }
    }
    
    option.appendChild(comboDisplay);
    
    // Hozzáadjuk a valós kombinációk jelölését
    if (isValid) {
      option.classList.add('valid-combo');
      option.style.borderBottom = '2px solid #7fff7f';
    }
    
    // Eseménykezelés a kiválasztáshoz
    option.addEventListener('click', () => {
      document.querySelectorAll('.combo-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      option.classList.add('selected');
      announceBtn.disabled = false;
    });
    
    comboSelector.appendChild(option);
  });
  
  if (filteredCombos.length === 0) {
    const noCombo = document.createElement('div');
    noCombo.textContent = 'Nincs lehetséges kombináció, amit bejelenthetnél. Az ellenfél nyer!';
    noCombo.style.color = '#ff6400';
    comboSelector.appendChild(noCombo);
    
    setTimeout(() => {
      endGame('bot');
    }, 2000);
  }
}

// Szám szó verzió (dice ikon osztálynévhez)
function getNumberWord(num) {
  const words = ['one', 'two', 'three', 'four', 'five', 'six'];
  return words[num - 1] || 'one';
}

// Kombinációs opciók generálása
function generateComboOptions() {
  updateComboSelector([], null);
}

// Játékos bejelent
function playerAnnounce() {
  if (gameState.currentPhase !== 'announce' || gameState.activePlayer !== 'player') return;
  
  const selectedOption = document.querySelector('.combo-option.selected');
  if (!selectedOption) return;
  
  const combo = selectedOption.dataset.combo;
  const diceValue = parseInt(selectedOption.dataset.diceValue);
  
  gameState.lastAnnouncement = {
    player: 'player',
    combo,
    diceValue,
    isReal: false // Még nem tudjuk, hogy valós-e
  };
  
  // Ellenőrizzük, hogy igazi-e a kombináció
  const validCombos = analyzeValidCombinations(gameState.playerDice);
  gameState.lastAnnouncement.isReal = validCombos.some(
    valid => valid.combo === combo && valid.diceValue === diceValue
  );
  
  addLogEntry(`Bejelentést tettél: ${formatComboName(combo, diceValue)}`);
  resultDisplay.textContent = `Bejelentés: ${formatComboName(combo, diceValue)}. A Sötét Nagyúr válaszára vársz.`;
  
  // Váltás válasz fázisra
  gameState.currentPhase = 'respond';
  gameState.activePlayer = 'bot';
  updateUI();
  
  // Bot gondolkodik és válaszol
  setTimeout(() => botRespond(), 2000);
}

// Bot bejelent
function botAnnounce() {
  if (gameState.currentPhase !== 'announce' || gameState.activePlayer !== 'bot') return;
  
  // Elemezzük a bot kockáit
  const validCombos = analyzeValidCombinations(gameState.botDice);
  
  // Bot stratégia a bejelentéshez
  let announcement = decideBotAnnouncement(validCombos);
  
  gameState.lastAnnouncement = {
    player: 'bot',
    combo: announcement.combo,
    diceValue: announcement.diceValue,
    isReal: announcement.isReal
  };
  
  addLogEntry(`A Sötét Nagyúr bejelentése: ${formatComboName(announcement.combo, announcement.diceValue)}`);
  resultDisplay.textContent = `A Sötét Nagyúr bejelentése: ${formatComboName(announcement.combo, announcement.diceValue)}. Mit teszel?`;
  
  // Váltás válasz fázisra
  gameState.currentPhase = 'respond';
  gameState.activePlayer = 'player';
  updateUI();
}

// Bot stratégia a bejelentéshez
function decideBotAnnouncement(validCombos) {
  const botIntelligence = 0.7; // 0-1 közötti érték, mennyire okos a bot (0: mindig igazat mond, 1: tökéletesen blöfföl)
  
  // Ha van valódi kombináció, eséllyel azt jelenti be
  if (validCombos.length > 0 && Math.random() > botIntelligence * 0.5) {
    const chosenCombo = validCombos[Math.floor(Math.random() * validCombos.length)];
    return {
      combo: chosenCombo.combo,
      diceValue: chosenCombo.diceValue,
      isReal: true
    };
  }
  
  // Különben blöfföl
  // Magasabb rangú kombinációt választ, mint az utolsó bejelentés, ha van
  let possibleCombos = [];
  
  for (let combo in COMBINATIONS) {
    for (let value = 1; value <= 6; value++) {
      if (!gameState.lastAnnouncement || 
          isHigherCombination(combo, value, gameState.lastAnnouncement.combo, gameState.lastAnnouncement.diceValue)) {
        possibleCombos.push({combo, diceValue: value});
      }
    }
  }
  
  // Ha nincs lehetséges kombináció, elbukta a játékot
  if (possibleCombos.length === 0) {
    addLogEntry('A Sötét Nagyúr nem tud magasabb értéket bejelenteni. Te nyertél!');
    endGame('player');
    return { combo: 'three', diceValue: 1, isReal: false }; // Csak kitöltés, nem fogja használni
  }
  
  // Súlyozás a kombinációk szerint - nem jelent be túl magas értéket, hogy hihetőbb legyen
  possibleCombos.sort((a, b) => {
    return rankCombination(a.combo, a.diceValue) - rankCombination(b.combo, b.diceValue);
  });
  
  // A legalacsonyabbak közül választ egyet
  const threshold = Math.floor(possibleCombos.length * (1 - botIntelligence));
  const chosenIndex = Math.floor(Math.random() * Math.min(3 + threshold, possibleCombos.length));
  const chosenCombo = possibleCombos[chosenIndex];
  
  return {
    combo: chosenCombo.combo,
    diceValue: chosenCombo.diceValue,
    isReal: false
  };
}

// Bot válaszol
function botRespond() {
  if (gameState.currentPhase !== 'respond' || gameState.activePlayer !== 'bot') return;
  
  // Bot elemzi az esélyeket és eldönti, hogy elhiszi-e vagy sem
  const botDecision = decideBotResponse();
  
  if (botDecision === 'believe') {
    addLogEntry('A Sötét Nagyúr elhiszi a bejelentésedet.');
    resultDisplay.textContent = 'A Sötét Nagyúr elhiszi a bejelentésedet. Most ő következik.';
    
    // Képesség ellenőrzése
    if (gameState.lastAnnouncement.isReal) {
      const ability = COMBINATIONS[gameState.lastAnnouncement.combo].ability;
      handlePlayerAbility(ability);
    } else {
      // Csak cseréljük az aktív játékost és lépünk tovább
      gameState.activePlayer = 'bot';
      gameState.currentPhase = 'roll';
      updateUI();
      setTimeout(() => botRoll(), 1500);
    }
  } else {
    addLogEntry('A Sötét Nagyúr kétségbe vonja a bejelentésedet!');
    resultDisplay.textContent = 'A Sötét Nagyúr kétségbe vonja a bejelentésedet! A kockák leleplezésre kerülnek...';
    
    // A játékos valós kockáinak megjelenítése
    displayDice(gameState.playerDice, playerDiceContainer);
    
    setTimeout(() => {
      resolveChallenge('player');
    }, 1500);
  }
}

// Bot stratégia a válaszhoz
function decideBotResponse() {
  const { combo, diceValue } = gameState.lastAnnouncement;
  const comboRank = COMBINATIONS[combo].rank;
  
  // Az ítélet alapja: minél magasabb rangú a bejelentett kombináció, annál valószínűbb, hogy kétségbe vonja
  let doubtProbability = 0.3; // Alap kétségbe vonás esélye
  
  // Kombináció rangjának hatása
  doubtProbability += comboRank * 0.1;
  
  // Korábbi bejelentések és a bot játékstílusa alapján további módosítások
  // A bot személyiségét itt tovább lehet finomítani
  
  // A bot "gondolkodik"
  return Math.random() < doubtProbability ? 'doubt' : 'believe';
}

// Játékos elhiszi
function playerBelieve() {
  if (gameState.currentPhase !== 'respond' || gameState.activePlayer !== 'player') return;
  
  addLogEntry('Elhiszed a Sötét Nagyúr bejelentését.');
  resultDisplay.textContent = 'Elhiszed a bejelentést. Most te következel.';
  
  // Képesség ellenőrzése
  if (gameState.lastAnnouncement.isReal) {
    const ability = COMBINATIONS[gameState.lastAnnouncement.combo].ability;
    handleBotAbility(ability);
  } else {
    // Csak cseréljük az aktív játékost és lépünk tovább
    gameState.activePlayer = 'player';
    gameState.currentPhase = 'roll';
    updateUI();
  }
}

// Játékos kétségbe von
function playerDoubt() {
  if (gameState.currentPhase !== 'respond' || gameState.activePlayer !== 'player') return;
  
  addLogEntry('Kétségbe vonod a Sötét Nagyúr bejelentését!');
  resultDisplay.textContent = 'Kétségbe vonod a bejelentést! A kockák leleplezésre kerülnek...';
  
  // A bot valós kockáinak megjelenítése
  displayDice(gameState.botDice, botDiceContainer);
  
  setTimeout(() => {
    resolveChallenge('bot');
  }, 1500);
}

// Kihívás eredményének feldolgozása
function resolveChallenge(challengedPlayer) {
  if (challengedPlayer !== 'player' && challengedPlayer !== 'bot') return;
  
  const announcement = gameState.lastAnnouncement;
  const isReal = announcement.isReal;
  
  if (isReal) {
    // A bejelentés igaz volt, a kihívó veszít
    let sparksLost = 1;
    
    // Full house képesség ellenőrzése (2 szikrát veszt, ha full house-t von kétségbe)
    if (announcement.combo === 'fullhouse') {
      sparksLost = 2;
      addLogEntry(`A bejelentés valódi volt! Ez full house, így ${sparksLost} isteni szikrát veszítesz!`);
    } else {
      addLogEntry('A bejelentés valódi volt! 1 isteni szikrát veszítesz.');
    }
    
    if (challengedPlayer === 'player') {
      // Bot veszít szikrát
      loseSparkWithCheck('bot', sparksLost);
    } else {
      // Játékos veszít szikrát
      loseSparkWithCheck('player', sparksLost);
    }
    
    // Képesség ellenőrzése
    const ability = COMBINATIONS[announcement.combo].ability;
    if (challengedPlayer === 'player') {
      handlePlayerAbility(ability);
    } else {
      handleBotAbility(ability);
    }
  } else {
    // A bejelentés hamis volt, a bejelentő veszít
    addLogEntry('A bejelentés hamis volt! A bejelentő 1 isteni szikrát veszít.');
    
    if (announcement.player === 'player') {
      // Játékos veszít szikrát
      loseSparkWithCheck('player', 1);
    } else {
      // Bot veszít szikrát
      loseSparkWithCheck('bot', 1);
    }
    
    // Új kör, a kihívott játékos kezd
    if (challengedPlayer === 'player') {
      // Játékos kezd
      gameState.activePlayer = 'player';
    } else {
      // Bot kezd
      gameState.activePlayer = 'bot';
    }
    
    // Új körben bármilyen értéket be lehet jelenteni
    gameState.lastAnnouncement = null;
    gameState.currentPhase = 'roll';
    updateUI();
    
    if (gameState.activePlayer === 'bot') {
      setTimeout(() => botRoll(), 1500);
    }
  }
}

// Isteni szikra vesztése pajzs képesség ellenőrzésével
function loseSparkWithCheck(player, count) {
  if (player !== 'player' && player !== 'bot') return;
  
  // Pajzs képesség ellenőrzése
  if (player === 'player' && gameState.playerAbilities.shield) {
    addLogEntry('A pajzs képességed megvéd egy isteni szikra elvesztésétől!');
    gameState.playerAbilities.shield = false;
    count -= 1;
  } else if (player === 'bot' && gameState.botAbilities.shield) {
    addLogEntry('A Sötét Nagyúr pajzsa megvédi egy isteni szikra elvesztésétől!');
    gameState.botAbilities.shield = false;
    count -= 1;
  }
  
  // Szikrák levonása
  if (count > 0) {
    if (player === 'player') {
      gameState.playerSparks = Math.max(0, gameState.playerSparks - count);
    } else {
      gameState.botSparks = Math.max(0, gameState.botSparks - count);
    }
  }
  
  // UI frissítése
  updateSparksDisplay();
  
  // Játék vége ellenőrzése
  if (gameState.playerSparks === 0 || gameState.botSparks === 0) {
    const winner = gameState.playerSparks > 0 ? 'player' : 'bot';
    endGame(winner);
  }
}

// Játékos képesség kezelése
function handlePlayerAbility(ability) {
  if (!ability) return;
  
  switch (ability) {
    case 'peek':
      abilityTitle.textContent = 'Meglesheted az ellenfél következő dobását!';
      abilityDescription.textContent = 'Használod a képességed, hogy meglásd a Sötét Nagyúr kockáit a következő körben?';
      gameState.currentPhase = 'ability';
      abilityPanel.style.display = 'block';
      break;
      
    case 'shield':
      abilityTitle.textContent = 'Pajzs képesség aktiválva!';
      abilityDescription.textContent = 'Védelmet kapsz egy isteni szikra elvesztése ellen.';
      gameState.currentPhase = 'ability';
      abilityPanel.style.display = 'block';
      break;
      
    case 'heal':
      abilityTitle.textContent = 'Gyógyítás képesség aktiválva!';
      abilityDescription.textContent = 'Visszaszerezhetsz egy elvesztett isteni szikrát.';
      gameState.currentPhase = 'ability';
      abilityPanel.style.display = 'block';
      break;
      
    case 'double':
      // Ezt már kezeltük a loseSparkWithCheck függvényben
      continueAfterAbility();
      break;
      
    default:
      continueAfterAbility();
  }
}

// Bot képesség kezelése
function handleBotAbility(ability) {
  if (!ability) return;
  
  switch (ability) {
    case 'peek':
      gameState.botAbilities.peek = true;
      addLogEntry('A Sötét Nagyúr meg fogja látni a következő dobásodat!');
      break;
      
    case 'shield':
      gameState.botAbilities.shield = true;
      addLogEntry('A Sötét Nagyúr védelmet kapott egy isteni szikra elvesztése ellen.');
      break;
      
    case 'heal':
      if (gameState.botSparks < 5) {
        gameState.botSparks++;
        addLogEntry('A Sötét Nagyúr visszaszerzett egy elvesztett isteni szikrát!');
        updateSparksDisplay();
      } else {
        addLogEntry('A Sötét Nagyúrnak már maximális isteni szikrája van, nem használja a képességet.');
      }
      break;
  }
  
  // Folytatás
  continueAfterAbility();
}

// Játék folytatása képesség után
function continueAfterAbility() {
  // Alapértelmezés szerint, a következő kört az a játékos kezdi, aki kétségbe vonta az igaz bejelentést
  gameState.currentPhase = 'roll';
  gameState.lastAnnouncement = null;
  updateUI();
  
  if (gameState.activePlayer === 'bot') {
    setTimeout(() => botRoll(), 1500);
  }
}

// Képesség használata
function useAbility() {
  const ability = COMBINATIONS[gameState.lastAnnouncement.combo].ability;
  
  switch (ability) {
    case 'peek':
      gameState.playerAbilities.peek = true;
      addLogEntry('Használod a képességet: meg fogod látni a Sötét Nagyúr következő dobását!');
      break;
      
    case 'shield':
      gameState.playerAbilities.shield = true;
      addLogEntry('Használod a képességet: védelmet kapsz egy isteni szikra elvesztése ellen.');
      break;
      
    case 'heal':
      if (gameState.playerSparks < 5) {
        gameState.playerSparks++;
        addLogEntry('Használod a képességet: visszaszereztél egy elvesztett isteni szikrát!');
        updateSparksDisplay();
      } else {
        addLogEntry('Már maximális isteni szikrád van, nem használtad a képességet.');
      }
      break;
  }
  
  abilityPanel.style.display = 'none';
  continueAfterAbility();
}

// Képesség kihagyása
function skipAbility() {
  addLogEntry('Nem használtad a képességet.');
  abilityPanel.style.display = 'none';
  continueAfterAbility();
}

// Játék vége
function endGame(winner) {
  gameState.currentPhase = 'end';
  
  if (winner === 'player') {
    resultDisplay.innerHTML = '<span class="winner">Gratulálok! Legyőzted a Sötét Nagyurat!</span>';
  } else {
    resultDisplay.innerHTML = '<span class="winner">A Sötét Nagyúr elpusztította a világodat! Elbukott a küldetésed.</span>';
  }
  
  resetContainer.style.display = 'block';
}

// Isteni szikrák megjelenítésének frissítése
function updateSparksDisplay() {
  playerSparksContainer.innerHTML = '';
  botSparksContainer.innerHTML = '';
  
  for (let i = 0; i < 5; i++) {
    const playerSpark = document.createElement('i');
    playerSpark.className = i < gameState.playerSparks ? 'fas fa-fire spark' : 'fas fa-fire spark lost-spark';
    playerSparksContainer.appendChild(playerSpark);
    
    const botSpark = document.createElement('i');
    botSpark.className = i < gameState.botSparks ? 'fas fa-fire spark' : 'fas fa-fire spark lost-spark';
    botSparksContainer.appendChild(botSpark);
  }
}

// UI frissítése a játék állapot alapján
function updateUI() {
  // Aktív játékos jelölése
  playerSection.classList.toggle('active-player', gameState.activePlayer === 'player');
  botSection.classList.toggle('active-player', gameState.activePlayer === 'bot');
  
  // Isteni szikrák frissítése
  updateSparksDisplay();
  
  // Gombok állapotának frissítése
  rollBtn.disabled = !(gameState.currentPhase === 'roll' && gameState.activePlayer === 'player');
  announceBtn.disabled = !(gameState.currentPhase === 'announce' && gameState.activePlayer === 'player');
  believeBtn.disabled = !(gameState.currentPhase === 'respond' && gameState.activePlayer === 'player');
  doubtBtn.disabled = !(gameState.currentPhase === 'respond' && gameState.activePlayer === 'player');
  
  // Combo selector láthatósága
  comboSelector.style.display = (gameState.currentPhase === 'announce' && gameState.activePlayer === 'player') ? 'flex' : 'none';
  
  // Announce panel címe
  const announceTitle = document.getElementById('announce-title');
  if (gameState.currentPhase === 'announce') {
    announceTitle.textContent = 'Válaszd ki a bejelentendő kombinációt';
  } else if (gameState.currentPhase === 'respond') {
    announceTitle.textContent = 'Elhiszed vagy kétségbe vonod?';
  } else {
    announceTitle.textContent = 'Válaszd ki a következő lépést';
  }
}

// Játéknapló kezelése
function addLogEntry(message) {
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.textContent = `» ${message}`;
  gameLog.appendChild(entry);
  gameLog.scrollTop = gameLog.scrollHeight;
}

function clearLog() {
  gameLog.innerHTML = '';
}

// Eseménykezelők
rollBtn.addEventListener('click', playerRoll);
announceBtn.addEventListener('click', playerAnnounce);
believeBtn.addEventListener('click', playerBelieve);
doubtBtn.addEventListener('click', playerDoubt);
useAbilityBtn.addEventListener('click', useAbility);
skipAbilityBtn.addEventListener('click', skipAbility);

// Játék indítása
startGame();
</script>

</body>
</html>
