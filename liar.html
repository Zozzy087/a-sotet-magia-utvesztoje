<!DOCTYPE html>
<html lang="hu">
<head>
  <meta charset="UTF-8">
  <title>Sötét Blöff - Mia Kockajáték</title>
  <link href="https://fonts.googleapis.com/css2?family=Eczar:wght@400..800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: "Eczar", serif;
      background-image: url('images/background.jpg.jpg');
      background-size: cover;
      background-position: center;
      color: #d1c3af;
      margin: 0;
      padding: 20px;
      text-align: center;
      background-color: #0c0c0c;
      min-height: 100vh;
    }
    h1 {
      font-size: 2.6rem;
      margin-bottom: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 5px;
      display: inline-block;
      text-shadow: 0 0 10px #ff6400;
      letter-spacing: 2px;
    }
    .game-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    .player-sections {
      display: flex;
      justify-content: space-between;
      gap: 30px;
      margin: 20px 0;
    }
    .player-section {
      background-color: rgba(20, 14, 10, 0.85);
      padding: 20px;
      border-radius: 5px;
      flex: 1;
      border: 1px solid #482c17;
      transition: all 0.3s ease;
      position: relative;
    }
    .active-player {
      border: 3px solid #ff6400;
      box-shadow: 0 0 25px rgba(255, 100, 0, 0.7);
      transform: scale(1.05);
      z-index: 2;
    }
    .active-player::before {
      content: "》";
      position: absolute;
      left: -30px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2.5rem;
      color: #ff6400;
      text-shadow: 0 0 10px #ff6400;
      animation: pulse 1.5s infinite;
    }
    .active-player::after {
      content: "《";
      position: absolute;
      right: -30px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2.5rem;
      color: #ff6400;
      text-shadow: 0 0 10px #ff6400;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    h2 {
      margin-top: 0;
      font-size: 1.8rem;
      color: #d1c3af;
    }
    .lives {
      margin: 15px 0;
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .life {
      width: 25px;
      height: 25px;
      background-color: #ff6400;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 10px rgba(255, 100, 0, 0.7);
    }
    .life.lost {
      background-color: #482c17;
      box-shadow: none;
    }
    .dice-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 30px auto;
      perspective: 600px;
    }
    .dice {
      width: 60px;
      height: 60px;
      background-color: #d1c3af;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2.5rem;
      font-weight: bold;
      color: #291d14;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.8s ease-out;
      box-shadow: 0 0 15px rgba(255, 100, 0, 0.5);
    }
    .dice.hidden {
      background-color: #291d14;
      color: transparent;
      box-shadow: 0 0 15px rgba(72, 44, 23, 0.7);
    }
    .dice.rolling {
      animation: diceRoll 1s ease-out;
    }
    @keyframes diceRoll {
      0% { transform: rotateX(0deg) rotateY(0deg); }
      25% { transform: rotateX(180deg) rotateY(90deg); }
      50% { transform: rotateX(270deg) rotateY(180deg); }
      75% { transform: rotateX(180deg) rotateY(270deg); }
      100% { transform: rotateX(360deg) rotateY(360deg); }
    }
    .cup {
      position: absolute;
      width: 150px;
      height: 120px;
      background-color: rgba(41, 29, 20, 0.9);
      border-radius: 5px 5px 70px 70px;
      top: -100px;
      left: 50%;
      transform: translateX(-50%);
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7), 0 0 10px rgba(0, 0, 0, 0.5);
      transition: top 0.5s ease-out;
      z-index: 10;
    }
    .cup.covering {
      top: -10px;
    }
    .cup::before {
      content: "";
      position: absolute;
      width: 160px;
      height: 20px;
      background-color: rgba(41, 29, 20, 0.9);
      border-radius: 50%;
      bottom: -5px;
      left: -5px;
      z-index: -1;
    }
    .game-status {
      font-size: 1.3rem;
      background-color: rgba(20, 14, 10, 0.7);
      padding: 15px;
      border-radius: 5px;
      margin: 20px auto;
      max-width: 90%;
      letter-spacing: 1px;
      line-height: 1.4;
    }
    .action-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 20px 0;
    }
    .claim-area {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .claim-display {
      background-color: rgba(72, 44, 23, 0.6);
      padding: 12px 25px;
      border-radius: 5px;
      font-size: 1.5rem;
      min-width: 100px;
    }
    .value-selector {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 15px 0;
      flex-wrap: wrap;
    }
    .value-btn {
      background-color: #291d14;
      color: #d1c3af;
      border: 1px solid #482c17;
      border-radius: 5px;
      padding: 8px;
      min-width: 40px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .value-btn:hover {
      background-color: #482c17;
      transform: scale(1.1);
    }
    .value-btn.selected {
      background-color: #ff6400;
      color: #291d14;
      border-color: #ff6400;
      font-weight: bold;
    }
    .value-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 15px;
      flex-wrap: wrap;
    }
    button {
      font-family: "Eczar", serif;
      font-size: 1.2rem;
      padding: 12px 25px;
      margin: 5px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background-color: #482c17;
      color: #d1c3af;
      box-shadow: 0 0 10px rgba(255, 100, 0, 0.3);
      transition: all 0.3s;
      letter-spacing: 1px;
    }
    button:hover:not(:disabled) {
      background-color: #5a381f;
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(255, 100, 0, 0.5);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.primary {
      background-color: #ff6400;
      color: #291d14;
    }
    button.primary:hover:not(:disabled) {
      background-color: #ff7d33;
    }
    .game-log {
      margin-top: 30px;
      background-color: rgba(20, 14, 10, 0.7);
      padding: 15px;
      border-radius: 5px;
      max-height: 150px;
      overflow-y: auto;
      text-align: left;
    }
    .log-entry {
      margin-bottom: 8px;
      border-bottom: 1px solid rgba(72, 44, 23, 0.5);
      padding-bottom: 8px;
    }
    .player-name {
      font-weight: bold;
      color: #ff6400;
    }
    .bot-name {
      font-weight: bold;
      color: #a94bff;
    }
    .value {
      font-weight: bold;
    }
    .rules-area {
      margin-top: 20px;
      background-color: rgba(20, 14, 10, 0.7);
      padding: 15px;
      border-radius: 5px;
      font-size: 0.9rem;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }
    .rules-toggle {
      background: none;
      border: none;
      color: #ff6400;
      cursor: pointer;
      text-decoration: underline;
      padding: 0;
      margin: 0;
      font-size: 1rem;
    }
    .rules-content {
      display: none;
      text-align: left;
      padding-top: 10px;
    }
    .rules-content.active {
      display: block;
    }
    .value-table {
      width: 100%;
      border-collapse: collapse;
      margin: 10px 0;
    }
    .value-table th, .value-table td {
      border: 1px solid #482c17;
      padding: 5px;
    }
    .value-table th {
      background-color: rgba(72, 44, 23, 0.6);
    }
    .game-over-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease;
    }
    .game-over-screen.active {
      opacity: 1;
      visibility: visible;
    }
    .game-over-content {
      background-color: rgba(20, 14, 10, 0.95);
      border: 3px solid #ff6400;
      border-radius: 10px;
      padding: 30px;
      max-width: 500px;
      text-align: center;
      box-shadow: 0 0 30px rgba(255, 100, 0, 0.7);
    }
    .game-over-title {
      font-size: 2.5rem;
      margin-bottom: 20px;
      color: #ff6400;
      text-shadow: 0 0 10px rgba(255, 100, 0, 0.7);
    }
    .game-over-message {
      font-size: 1.2rem;
      margin-bottom: 30px;
      line-height: 1.5;
    }
    
    /* Responsive styling */
    @media (max-width: 768px) {
      .player-sections {
        flex-direction: column;
      }
      .active-player::before,
      .active-player::after {
        display: none;
      }
      .claim-area {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

<div class="game-container">
  <h1>Sötét Blöff</h1>
  
  <div class="player-sections">
    <div id="player-section" class="player-section active-player">
      <h2>Kalandor</h2>
      <div id="player-lives" class="lives">
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
      </div>
    </div>
    
    <div id="bot-section" class="player-section">
      <h2>Sötét Nagyúr</h2>
      <div id="bot-lives" class="lives">
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
        <div class="life"></div>
      </div>
    </div>
  </div>
  
  <div class="dice-section">
    <div class="dice-container">
      <div id="cup" class="cup"></div>
      <div id="dice1" class="dice hidden">1</div>
      <div id="dice2" class="dice hidden">1</div>
    </div>
  </div>
  
  <div id="game-status" class="game-status">
    A játék kezdődik. Készülj a blöffölésre...
  </div>
  
  <div class="action-area">
    <div class="claim-area">
      <div>Aktuális állítás:</div>
      <div id="current-claim" class="claim-display">Nincs</div>
    </div>
    
    <div id="value-selection" class="value-selector" style="display: none;">
      <!-- Ezeket a gombokat dinamikusan hozzuk létre a JavaScript kódban -->
    </div>
    
    <div id="action-buttons" class="action-buttons">
      <button id="roll-btn" class="primary">Kockadobás</button>
      <button id="claim-btn" style="display: none;">Állítás</button>
      <button id="pass-btn" style="display: none;">Elfogadás</button>
      <button id="check-btn" style="display: none;">Ellenőrzés</button>
    </div>
  </div>
  
  <div class="game-log">
    <div id="log-container"></div>
  </div>
  
  <div class="rules-area">
    <button id="rules-toggle" class="rules-toggle">Játékszabályok mutatása ▼</button>
    <div id="rules-content" class="rules-content">
      <p>A Mia egy blöffölős kockajáték, amiben két dobókockával játszunk.</p>
      <ul>
        <li>Minden játékos 6 élettel kezd.</li>
        <li>A játékosok felváltva dobnak a két kockával, és bejelentik az eredményt - ami lehet az igazság vagy hazugság is.</li>
        <li>A következő játékos vagy elfogadja az állítást és magasabb értéket jelent be, vagy ellenőrzi a dobást.</li>
        <li>Ha az ellenőrzés során hazugságon érik, a hazug veszít egy életet. Ha az állítás igaz volt, az ellenőrző veszít egy életet.</li>
        <li>Az nyer, akinek marad élete, amikor az ellenfélnek már nincs.</li>
      </ul>
      
      <p><strong>Értékek sorrendje (növekvő sorrendben):</strong></p>
      <table class="value-table">
        <tr>
          <th>Dobás</th>
          <th>Érték</th>
          <th>Megjegyzés</th>
        </tr>
        <tr>
          <td>3-1</td>
          <td>Legalacsonyabb</td>
          <td></td>
        </tr>
        <tr>
          <td>3-2, 4-1, 4-2, 4-3, 5-1, 5-2, 5-3, 5-4, 6-1, 6-2, 6-3, 6-4, 6-5</td>
          <td>Közepesek</td>
          <td>Növekvő sorrendben</td>
        </tr>
        <tr>
          <td>1-1, 2-2, 3-3, 4-4, 5-5, 6-6</td>
          <td>Duplák</td>
          <td>Növekvő sorrendben</td>
        </tr>
        <tr>
          <td>2-1</td>
          <td>Mia (legmagasabb)</td>
          <td></td>
        </tr>
      </table>
    </div>
  </div>
</div>

<div id="game-over" class="game-over-screen">
  <div class="game-over-content">
    <h2 class="game-over-title">Játék Vége</h2>
    <div id="game-over-message" class="game-over-message"></div>
    <button id="new-game-btn" class="primary">Új Játék</button>
  </div>
</div>

<script>
// Konstansok és segédfüggvények
const DICE_VALUES = {
  '21': { display: 'Mia', value: 100 },  // Legmagasabb érték
  '11': { display: '1-1', value: 90 },
  '22': { display: '2-2', value: 91 },
  '33': { display: '3-3', value: 92 },
  '44': { display: '4-4', value: 93 },
  '55': { display: '5-5', value: 94 },
  '66': { display: '6-6', value: 95 },
  '31': { display: '3-1', value: 1 },    // Legalacsonyabb érték
  '32': { display: '3-2', value: 2 },
  '41': { display: '4-1', value: 3 },
  '42': { display: '4-2', value: 4 },
  '43': { display: '4-3', value: 5 },
  '51': { display: '5-1', value: 6 },
  '52': { display: '5-2', value: 7 },
  '53': { display: '5-3', value: 8 },
  '54': { display: '5-4', value: 9 },
  '61': { display: '6-1', value: 10 },
  '62': { display: '6-2', value: 11 },
  '63': { display: '6-3', value: 12 },
  '64': { display: '6-4', value: 13 },
  '65': { display: '6-5', value: 14 }
};

// Minden érték kulcsát tároljuk növekvő sorrendben
const SORTED_VALUES = Object.keys(DICE_VALUES).sort((a, b) => 
  DICE_VALUES[a].value - DICE_VALUES[b].value
);

// Normalizálja a kocka értéket a megfelelő formátumba (pl. 2-1 helyett 21)
function normalizeDiceValue(dice1, dice2) {
  // Mia speciális eset
  if ((dice1 === 2 && dice2 === 1) || (dice1 === 1 && dice2 === 2)) {
    return '21';
  }
  // A többi érték esetén a nagyobb érték jön előre
  return dice1 >= dice2 ? `${dice1}${dice2}` : `${dice2}${dice1}`;
}

// Egy véletlen egész szám generálása min és max között (mindkettő beleértve)
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Játék állapot
const gameState = {
  playerLives: 6,
  botLives: 6,
  currentPlayer: 'player', // 'player' vagy 'bot'
  diceValues: [1, 1],
  currentClaim: null,
  gamePhase: 'roll', // 'roll', 'claim', 'decision'
  lastClaimTruthful: false,
  playerClaimHistory: [],
  botClaimHistory: [],
  turnCount: 0,
  gameOver: false
};

// DOM elemek
const playerSection = document.getElementById('player-section');
const botSection = document.getElementById('bot-section');
const dice1Element = document.getElementById('dice1');
const dice2Element = document.getElementById('dice2');
const cupElement = document.getElementById('cup');
const gameStatusElement = document.getElementById('game-status');
const currentClaimElement = document.getElementById('current-claim');
const valueSelectionElement = document.getElementById('value-selection');
const rollButton = document.getElementById('roll-btn');
const claimButton = document.getElementById('claim-btn');
const passButton = document.getElementById('pass-btn');
const checkButton = document.getElementById('check-btn');
const logContainer = document.getElementById('log-container');
const rulesToggle = document.getElementById('rules-toggle');
const rulesContent = document.getElementById('rules-content');
const gameOverScreen = document.getElementById('game-over');
const gameOverMessage = document.getElementById('game-over-message');
const newGameButton = document.getElementById('new-game-btn');

// Eseménykezelők beállítása
rollButton.addEventListener('click', handleRoll);
claimButton.addEventListener('click', handleClaim);
passButton.addEventListener('click', handlePass);
checkButton.addEventListener('click', handleCheck);
rulesToggle.addEventListener('click', toggleRules);
newGameButton.addEventListener('click', startNewGame);

// Értékválasztó gombok létrehozása
function createValueButtons() {
  valueSelectionElement.innerHTML = '';
  
  SORTED_VALUES.forEach(value => {
    const button = document.createElement('button');
    button.classList.add('value-btn');
    button.dataset.value = value;
    button.textContent = DICE_VALUES[value].display;
    button.addEventListener('click', () => selectValue(value));
    valueSelectionElement.appendChild(button);
  });
}

// Érték kiválasztása
function selectValue(value) {
  // Már kiválasztott gombok törlése
  document.querySelectorAll('.value-btn.selected').forEach(btn => 
    btn.classList.remove('selected')
  );
  
  // Új érték kiválasztása
  document.querySelector(`.value-btn[data-value="${value}"]`).classList.add('selected');
  gameState.selectedValue = value;
  
  // Claim gomb engedélyezése
  claimButton.disabled = false;
}

// Játék indítása
function initGame() {
  createValueButtons();
  updateLivesDisplay();
  addLogEntry('A játék elkezdődött. Jó blöffölést!', 'system');
  updateGameStatus('Dobj a kockákkal a kezdéshez!');
  updateUI();
}

// Játék újraindítása
function startNewGame() {
  gameState.playerLives = 6;
  gameState.botLives = 6;
  gameState.currentPlayer = 'player';
  gameState.diceValues = [1, 1];
  gameState.currentClaim = null;
  gameState.gamePhase = 'roll';
  gameState.lastClaimTruthful = false;
  gameState.playerClaimHistory = [];
  gameState.botClaimHistory = [];
  gameState.turnCount = 0;
  gameState.gameOver = false;
  
  // UI visszaállítása
  currentClaimElement.textContent = 'Nincs';
  logContainer.innerHTML = '';
  gameOverScreen.classList.remove('active');
  
  updateLivesDisplay();
  addLogEntry('Új játék kezdődött. Jó blöffölést!', 'system');
  updateGameStatus('Dobj a kockákkal a kezdéshez!');
  updateUI();
}

// Életpontok megjelenítésének frissítése
function updateLivesDisplay() {
  // Játékos életei
  const playerLivesContainer = document.getElementById('player-lives');
  playerLivesContainer.innerHTML = '';
  
  for (let i = 0; i < 6; i++) {
    const lifeElement = document.createElement('div');
    lifeElement.classList.add('life');
    if (i >= gameState.playerLives) {
      lifeElement.classList.add('lost');
    }
    playerLivesContainer.appendChild(lifeElement);
  }
  
  // Bot életei
  const botLivesContainer = document.getElementById('bot-lives');
  botLivesContainer.innerHTML = '';
  
  for (let i = 0; i < 6; i++) {
    const lifeElement = document.createElement('div');
    lifeElement.classList.add('life');
    if (i >= gameState.botLives) {
      lifeElement.classList.add('lost');
    }
    botLivesContainer.appendChild(lifeElement);
  }
}

// Játék állapot megjelenítés frissítése
function updateGameStatus(message) {
  gameStatusElement.textContent = message;
}

// Log bejegyzés hozzáadása
function addLogEntry(message, type, value = null) {
  const logEntry = document.createElement('div');
  logEntry.classList.add('log-entry');
  
  if (type === 'player-claim') {
    logEntry.innerHTML = `<span class="player-name">Kalandor</span> állítása: <span class="value">${DICE_VALUES[value].display}</span>`;
  } else if (type === 'bot-claim') {
    logEntry.innerHTML = `<span class="bot-name">Sötét Nagyúr</span> állítása: <span class="value">${DICE_VALUES[value].display}</span>`;
  } else if (type === 'player-check') {
    logEntry.innerHTML = `<span class="player-name">Kalandor</span> ellenőrizte a dobást!`;
  } else if (type === 'bot-check') {
    logEntry.innerHTML = `<span class="bot-name">Sötét Nagyúr</span> ellenőrizte a dobást!`;
  } else if (type === 'player-pass') {
    logEntry.innerHTML = `<span class="player-name">Kalandor</span> elfogadta az állítást.`;
  } else if (type === 'bot-pass') {
    logEntry.innerHTML = `<span class="bot-name">Sötét Nagyúr</span> elfogadta az állítást.`;
  } else if (type === 'player-roll') {
    logEntry.innerHTML = `<span class="player-name">Kalandor</span> dobott a kockákkal.`;
  } else if (type === 'bot-roll') {
    logEntry.innerHTML = `<span class="bot-name">Sötét Nagyúr</span> dobott a kockákkal.`;
  } else if (type === 'lose-life') {
    logEntry.innerHTML = `<span class="${value === 'player' ? 'player-name' : 'bot-name'}">${value === 'player' ? 'Kalandor' : 'Sötét Nagyúr'}</span> vesztett egy életet!`;
  } else {
    logEntry.textContent = message;
  }
  
  logContainer.insertBefore(logEntry, logContainer.firstChild);
}

// UI frissítése az aktuális játékállapot alapján
function updateUI() {
  // Aktív játékos kiemelése
  if (gameState.currentPlayer === 'player') {
    playerSection.classList.add('active-player');
    botSection.classList.remove('active-player');
  } else {
    playerSection.classList.remove('active-player');
    botSection.classList.add('active-player');
  }
  
  // Gombok megjelenítése/elrejtése a játékfázisnak megfelelően
  if (gameState.gamePhase === 'roll') {
    rollButton.style.display = 'block';
    claimButton.style.display = 'none';
    passButton.style.display = 'none';
    checkButton.style.display = 'none';
    valueSelectionElement.style.display = 'none';
    
    // A gomb elérhetősége az aktuális játékostól függ
    rollButton.disabled = gameState.currentPlayer !== 'player';
    
    // Ha a bot következik, kezdje meg a lépését
    if (gameState.currentPlayer === 'bot' && !gameState.gameOver) {
      setTimeout(botTurn, 1500);
    }
  } else if (gameState.gamePhase === 'claim') {
    rollButton.style.display = 'none';
    claimButton.style.display = 'block';
    passButton.style.display = 'none';
    checkButton.style.display = 'none';
    valueSelectionElement.style.display = 'flex';
    
    // A claim gomb kezdetben le van tiltva, amíg nincs érték kiválasztva
    claimButton.disabled = !gameState.selectedValue;
    
    // Elérhető értékek szűrése, ha már van korábbi állítás
    updateAvailableValues();
    
    // Ha a bot következik, kezdje meg a lépését
    if (gameState.currentPlayer === 'bot' && !gameState.gameOver) {
      setTimeout(botClaim, 2000);
    }
  } else if (gameState.gamePhase === 'decision') {
    rollButton.style.display = 'none';
    claimButton.style.display = 'none';
    passButton.style.display = 'block';
    checkButton.style.display = 'block';
    valueSelectionElement.style.display = 'none';
    
    // Gombok elérhetősége az aktuális játékostól függ
    passButton.disabled = checkButton.disabled = gameState.currentPlayer !== 'player';
    
    // Ha a bot következik, kezdje meg a lépését
    if (gameState.currentPlayer === 'bot' && !gameState.gameOver) {
      setTimeout(botDecision, 2000);
    }
  }
}

// Elérhető értékek frissítése
function updateAvailableValues() {
  if (!gameState.currentClaim) return;
  
  const currentClaimValue = DICE_VALUES[gameState.currentClaim].value;
  const allButtons = document.querySelectorAll('.value-btn');
  
  allButtons.forEach(button => {
    const buttonValue = button.dataset.value;
    const valueInfo = DICE_VALUES[buttonValue];
    
    if (valueInfo.value <= currentClaimValue) {
      button.classList.add('disabled');
      button.disabled = true;
    } else {
      button.classList.remove('disabled');
      button.disabled = false;
    }
  });
}

// Dobás kezelése
function handleRoll() {
  if (gameState.gamePhase !== 'roll' || gameState.currentPlayer !== 'player') return;
  
  addLogEntry('', 'player-roll');
  
  // Kockadobás animáció
  dice1Element.classList.add('rolling');
  dice2Element.classList.add('rolling');
  cupElement.classList.add('covering');
  
  // Véletlenszerű dobás
  setTimeout(() => {
    gameState.diceValues = [
      randomInt(1, 6),
      randomInt(1, 6)
    ];
    
    dice1Element.textContent = gameState.diceValues[0];
    dice2Element.textContent = gameState.diceValues[1];
    
    dice1Element.classList.remove('hidden', 'rolling');
    dice2Element.classList.remove('hidden', 'rolling');
    
    // Normalizált dobott érték
    const rolledValue = normalizeDiceValue(gameState.diceValues[0], gameState.diceValues[1]);
    
    updateGameStatus(`Dobtál: ${DICE_VALUES[rolledValue].display}. Mit állítasz?`);
    
    // Átváltás a claim fázisra
    gameState.gamePhase = 'claim';
    updateUI();
  }, 1000);
}

// Állítás kezelése
function handleClaim() {
  if (gameState.gamePhase !== 'claim' || gameState.currentPlayer !== 'player') return;
  
  const claimedValue = gameState.selectedValue;
  const actualValue = normalizeDiceValue(gameState.diceValues[0], gameState.diceValues[1]);
  
  // Állítás rögzítése
  gameState.currentClaim = claimedValue;
  gameState.lastClaimTruthful = (claimedValue === actualValue);
  
  // Játékos állításának tárolása elemzéshez
  gameState.playerClaimHistory.push({
    actual: actualValue,
    claimed: claimedValue,
    truthful: (claimedValue === actualValue),
    turnCount: gameState.turnCount
  });
  
  addLogEntry('', 'player-claim', claimedValue);
  updateGameStatus(`Állításod: ${DICE_VALUES[claimedValue].display}. A Sötét Nagyúr következik.`);
  
  // Kockák elrejtése és pohár letakarása
  dice1Element.classList.add('hidden');
  dice2Element.classList.add('hidden');
  cupElement.classList.add('covering');
  
  // Játékos váltása és fázis átállítása
  gameState.currentPlayer = 'bot';
  gameState.gamePhase = 'decision';
  gameState.turnCount++;
  
  currentClaimElement.textContent = DICE_VALUES[claimedValue].display;
  
  updateUI();
}

// Állítás elfogadása
function handlePass() {
  if (gameState.gamePhase !== 'decision' || gameState.currentPlayer !== 'player') return;
  
  addLogEntry('', 'player-pass');
  updateGameStatus('Elfogadtad az állítást. Most te dobsz és állítasz valamit.');
  
  // Játékos dobása következik
  gameState.gamePhase = 'roll';
  gameState.currentPlayer = 'player';
  
  updateUI();
}

// Állítás ellenőrzése
function handleCheck() {
  if (gameState.gamePhase !== 'decision' || gameState.currentPlayer !== 'player') return;
  
  addLogEntry('', 'player-check');
  
  // Kockák felfedése
  dice1Element.classList.remove('hidden');
  dice2Element.classList.remove('hidden');
  cupElement.classList.remove('covering');
  
  // Bot által legutóbb dobott érték
  const actualValue = normalizeDiceValue(gameState.diceValues[0], gameState.diceValues[1]);
  
  // Eredmény kiértékelése
  if (gameState.currentClaim === actualValue) {
    // Bot igazat mondott, játékos veszít egy életet
    gameState.playerLives--;
    addLogEntry('', 'lose-life', 'player');
    updateGameStatus(`A Sötét Nagyúr igazat mondott! Valóban ${DICE_VALUES[actualValue].display}-t dobott. Vesztesz egy életet.`);
  } else {
    // Bot hazudott, bot veszít egy életet
    gameState.botLives--;
    addLogEntry('', 'lose-life', 'bot');
    updateGameStatus(`A Sötét Nagyúr hazudott! Valójában ${DICE_VALUES[actualValue].display}-t dobott, nem ${DICE_VALUES[gameState.currentClaim].display}-t. Ő veszít egy életet.`);
  }
  
  updateLivesDisplay();
  
  // Ellenőrizzük, vége-e a játéknak
  if (checkGameOver()) {
    return;
  }
  
  // Bot dob következőként
  setTimeout(() => {
    gameState.gamePhase = 'roll';
    gameState.currentPlayer = 'bot';
    gameState.currentClaim = null;
    currentClaimElement.textContent = 'Nincs';
    updateUI();
  }, 2500);
}

// Bot fordulója
function botTurn() {
  if (gameState.gamePhase !== 'roll' || gameState.currentPlayer !== 'bot') return;
  
  addLogEntry('', 'bot-roll');
  updateGameStatus('A Sötét Nagyúr dob a kockákkal...');
  
  // Kockadobás animáció
  dice1Element.classList.add('rolling');
  dice2Element.classList.add('rolling');
  cupElement.classList.add('covering');
  
  // Véletlenszerű dobás
  setTimeout(() => {
    gameState.diceValues = [
      randomInt(1, 6),
      randomInt(1, 6)
    ];
    
    dice1Element.textContent = gameState.diceValues[0];
    dice2Element.textContent = gameState.diceValues[1];
    
    // A kockákat csak a botnak mutatjuk, a játékosnak nem
    dice1Element.classList.add('hidden');
    dice1Element.classList.remove('rolling');
    dice2Element.classList.add('hidden');
    dice2Element.classList.remove('rolling');
    
    // Átváltás a claim fázisra
    gameState.gamePhase = 'claim';
    updateUI();
  }, 1000);
}

// Bot állítása
function botClaim() {
  if (gameState.gamePhase !== 'claim' || gameState.currentPlayer !== 'bot') return;
  
  const actualValue = normalizeDiceValue(gameState.diceValues[0], gameState.diceValues[1]);
  
  // Bot intelligencia: állítás meghatározása
  let claimedValue = determineBotClaim(actualValue);
  
  // Állítás rögzítése
  gameState.currentClaim = claimedValue;
  gameState.lastClaimTruthful = (claimedValue === actualValue);
  
  // Bot állításának tárolása
  gameState.botClaimHistory.push({
    actual: actualValue,
    claimed: claimedValue,
    truthful: (claimedValue === actualValue),
    turnCount: gameState.turnCount
  });
  
  addLogEntry('', 'bot-claim', claimedValue);
  updateGameStatus(`A Sötét Nagyúr állítása: ${DICE_VALUES[claimedValue].display}. Mit teszel?`);
  
  // Játékos következik
  gameState.currentPlayer = 'player';
  gameState.gamePhase = 'decision';
  gameState.turnCount++;
  
  currentClaimElement.textContent = DICE_VALUES[claimedValue].display;
  
  updateUI();
}

// Bot döntése (elfogadás vagy ellenőrzés)
function botDecision() {
  if (gameState.gamePhase !== 'decision' || gameState.currentPlayer !== 'bot') return;
  
  // Bot intelligencia: döntés meghozatala
  const shouldCheck = decideBotShouldCheck();
  
  if (shouldCheck) {
    // Bot ellenőrzést választ
    addLogEntry('', 'bot-check');
    
    // Kockák felfedése
    dice1Element.classList.remove('hidden');
    dice2Element.classList.remove('hidden');
    cupElement.classList.remove('covering');
    
    // Játékos által legutóbb dobott érték
    const actualValue = normalizeDiceValue(gameState.diceValues[0], gameState.diceValues[1]);
    
    // Eredmény kiértékelése
    if (gameState.currentClaim === actualValue) {
      // Játékos igazat mondott, bot veszít egy életet
      gameState.botLives--;
      addLogEntry('', 'lose-life', 'bot');
      updateGameStatus(`Igazat mondtál! Valóban ${DICE_VALUES[actualValue].display}-t dobtál. A Sötét Nagyúr veszít egy életet.`);
    } else {
      // Játékos hazudott, játékos veszít egy életet
      gameState.playerLives--;
      addLogEntry('', 'lose-life', 'player');
      updateGameStatus(`Hazudtál! Valójában ${DICE_VALUES[actualValue].display}-t dobtál, nem ${DICE_VALUES[gameState.currentClaim].display}-t. Vesztesz egy életet.`);
    }
    
    updateLivesDisplay();
    
    // Ellenőrizzük, vége-e a játéknak
    if (checkGameOver()) {
      return;
    }
    
    // Játékos dob következőként
    setTimeout(() => {
      gameState.gamePhase = 'roll';
      gameState.currentPlayer = 'player';
      gameState.currentClaim = null;
      currentClaimElement.textContent = 'Nincs';
      updateUI();
    }, 2500);
  } else {
    // Bot elfogadja az állítást
    addLogEntry('', 'bot-pass');
    updateGameStatus('A Sötét Nagyúr elfogadta az állításodat. Most ő dob és állít valamit.');
    
    // Bot dobása következik
    gameState.gamePhase = 'roll';
    gameState.currentPlayer = 'bot';
    
    updateUI();
  }
}

// Bot intelligencia: állítás meghatározása
function determineBotClaim(actualValue) {
  // Aktuális dobott érték 
  const actualValueInfo = DICE_VALUES[actualValue];
  
  // Előző állítás, ha van
  const previousClaimValue = gameState.currentClaim ? 
    DICE_VALUES[gameState.currentClaim].value : 0;
  
  // Blöffölési esély alapvariációja
  let bluffChance = 0.4;
  
  // Bot alkalmazkodik a játékos viselkedéséhez
  if (gameState.playerClaimHistory.length > 3) {
    // Ha a játékos gyakran blöfföl
    const playerBluffRate = gameState.playerClaimHistory
      .filter(entry => !entry.truthful).length / gameState.playerClaimHistory.length;
    
    // Ha a játékos gyakran blöfföl, a bot is gyakrabban teszi
    if (playerBluffRate > 0.6) {
      bluffChance += 0.2;
    }
    // Ha a játékos ritkán blöfföl, a bot óvatosabb
    else if (playerBluffRate < 0.3) {
      bluffChance -= 0.1;
    }
  }
  
  // Bot agresszívebb, ha vesztésre áll
  if (gameState.botLives < gameState.playerLives) {
    bluffChance += 0.1 * (gameState.playerLives - gameState.botLives);
  }
  
  // Később a játékban több kockázatot vállal
  bluffChance += Math.min(0.2, gameState.turnCount * 0.01);
  
  // Jó kéz esetén nem blöfföl annyira
  if (actualValueInfo.value > 80) { // Duplák és Mia
    bluffChance -= 0.3;
  } else if (actualValueInfo.value > 7) { // Jó normál kéz
    bluffChance -= 0.1;
  }
  
  // Döntés: igazat mond-e vagy blöfföl
  const willTellTruth = Math.random() > bluffChance;
  
  if (willTellTruth) {
    // Igazat mond
    return actualValue;
  } else {
    // Blöff: keresünk egy magasabb értéket
    
    // Ha nincs előző állítás, akkor csak egy jó értéket választunk
    if (!gameState.currentClaim) {
      // Választunk egy véletlenszerű nagyobb értéket
      const betterValues = SORTED_VALUES.filter(key => 
        DICE_VALUES[key].value > actualValueInfo.value
      );
      
      // Átlagos értéket választ, nem túl magasat, nem túl alacsonyt
      const randomIndex = Math.floor(Math.random() * betterValues.length * 0.7);
      return betterValues[randomIndex];
    } else {
      // Korábbi állításnál jobbat kell mondani
      const betterValues = SORTED_VALUES.filter(key => 
        DICE_VALUES[key].value > previousClaimValue
      );
      
      if (betterValues.length === 0) {
        // Nincs jobb, kénytelen igazat mondani
        return actualValue;
      }
      
      // A bot okos, nem választ túl magas értéket
      // A következő szabályok alapján választ:
      
      // 1. Ha nagyon rossz lapja van, de az előző állítás alacsony, nagyobbat mer mondani
      if (actualValueInfo.value < 5 && previousClaimValue < 40) {
        const randomIndex = Math.floor(Math.random() * betterValues.length * 0.3);
        return betterValues[randomIndex];
      }
      
      // 2. Átlagos esetben a következő 2-3 értékből választ 
      if (betterValues.length <= 3) {
        return betterValues[0];
      } else {
        const randomIndex = Math.floor(Math.random() * 3);
        return betterValues[randomIndex];
      }
    }
  }
}

// Bot intelligencia: eldönti, ellenőriz-e
function decideBotShouldCheck() {
  // Aktuális állítás értéke
  const currentClaimValue = DICE_VALUES[gameState.currentClaim].value;
  
  // Játékos blöffölési gyakorisága
  let playerBluffRate = 0.5; // Alapértelmezett, ha nincs történet
  if (gameState.playerClaimHistory.length > 0) {
    playerBluffRate = gameState.playerClaimHistory
      .filter(entry => !entry.truthful).length / gameState.playerClaimHistory.length;
  }
  
  // Alap ellenőrzési esély, az állítás értékétől függően
  let checkChance = 0;
  
  // Mia (nagyon ritka, nagy eséllyel blöff)
  if (currentClaimValue === 100) {
    checkChance = 0.8;
  }
  // Duplák (ritkák, közepes esély)
  else if (currentClaimValue >= 90) {
    checkChance = 0.6;
  }
  // Magas értékek (közepesen nehéz megkapni)
  else if (currentClaimValue >= 10) {
    checkChance = 0.4;
  }
  // Alacsony értékek (könnyebb megkapni)
  else {
    checkChance = 0.2;
  }
  
  // Játékos blöffölési gyakorisága növeli vagy csökkenti az ellenőrzési esélyt
  checkChance += (playerBluffRate - 0.5) * 0.4;
  
  // Bot életei befolyásolják a kockázatvállalási hajlandóságot
  if (gameState.botLives <= 2) {
    // Kevés élet esetén kockázatvállalóbb
    checkChance -= 0.2;
  }
  
  // Előző körök tanulságai
  if (gameState.playerClaimHistory.length >= 3) {
    // Utolsó 3 kör elemzése
    const recentHistory = gameState.playerClaimHistory.slice(-3);
    
    // Ha a játékos sokat blöfföl a magasabb értékekkel
    const highValueBluffs = recentHistory.filter(entry => 
      DICE_VALUES[entry.claimed].value > 50 && !entry.truthful
    ).length;
    
    if (highValueBluffs >= 2) {
      checkChance += 0.3;
    }
    
    // Ha a játékos mintázata: alacsony érték -> igaz, magas érték -> blöff
    if (recentHistory.every(entry => 
      (DICE_VALUES[entry.claimed].value <= 50 && entry.truthful) ||
      (DICE_VALUES[entry.claimed].value > 50 && !entry.truthful)
    )) {
      checkChance += 0.2;
    }
  }
  
  // Iowai gambling task algoritmus - a bot kockázatvállalása függhet az eddigi sikerességétől is
  // Ha a korábbi ellenőrzéseknél nyert, hajlamosabb újra ellenőrizni
  
  // Végső döntés
  return Math.random() < checkChance;
}

// Játék végének ellenőrzése
function checkGameOver() {
  if (gameState.playerLives <= 0) {
    // Játékos vesztett
    gameState.gameOver = true;
    showGameOver('A Sötét Nagyúr legyőzött! Elvesztetted a játékot.');
    return true;
  } else if (gameState.botLives <= 0) {
    // Bot vesztett
    gameState.gameOver = true;
    showGameOver('Gratulálok! Legyőzted a Sötét Nagyurat a blöffölési képességeiddel!');
    return true;
  }
  
  return false;
}

// Játék vége képernyő megjelenítése
function showGameOver(message) {
  gameOverMessage.textContent = message;
  gameOverScreen.classList.add('active');
}

// Szabályok megjelenítése/elrejtése
function toggleRules() {
  rulesContent.classList.toggle('active');
  rulesToggle.textContent = rulesContent.classList.contains('active') ? 
    'Játékszabályok elrejtése ▲' : 'Játékszabályok mutatása ▼';
}

// Játék indítása
initGame();
</script>

</body>
</html>
